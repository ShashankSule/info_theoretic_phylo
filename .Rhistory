View(coiii_data)
coiii_data[1,]
coiii_data
coiii_data[[1:4]]
coiii_data[[1]]
coiii_data[[2]]
attributes(coiii_data)
?as.phyDat
allSitePattern(10)
coiii_pond <- as.phyDat(coiii_data)
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
p_xy <- base.freq(as.DNAbin(sequence))
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
p_a <- length(A)/length(sequence)
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
p_b <- length(B)/length(sequence)
h_xy <- 0
h_x <- 0
h_y <- 0
# Computing p(x,y)
I <- 0
# for(i in c(1:4)){
#   if(p_xy[i] !=0){
#     h_xy <- h_xy -p_xy[i]*log2(p_xy[i])
#   }
#   if(p_x[i] != 0){
#     h_x <- h_x -p_x[i]*log2(p_x[i])
#   }
#   if(p_y[i] != 0){
#     h_y <- h_y -p_y[i]*log2(p_y[i])
#   }
# }
# I <- h_xy - p_a*h_x - p_b*h_y
for(i in c(1:4)){
if(p_x[i] !=0 ){
I <- I - p_b*p_y[i]*log2(p_x[i])
}
if(p_y[i] != 0){
I <- I - p_a*p_x[i]*log2(p_y[i])
}
}
return(I)
}
infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^(length(sequence))-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
print(paste("I =",I))
if(I < max_val){
max_val <- I
max_part <- partition
}
}
print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
infopart(coiii_pond[c("Bovine", "Seal", "Human", "Whale"),])
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
trials <- coiii_pond[,1:12]
trials <- coiii_pond[,1:12]
trials
attributes(trials)
length(trials)
names(trials)[1:2]
names(trials)[[1]]
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
#install.packages("TreeTools")
library("TreeTools")
raw_data <- ReadCharacters("coiii.nex")
mutual_info <- function(partition, sequence, pos) {
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
pxy_all <- base.freq(as.DNAbin(sequence[, pos]), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition, pos]
B <- sequence[!partition, pos]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
# Computing weight
#w_x <- length(A)/length(sequence)
#w_y <- length(B)/length(sequence)
w_x <- length(A) / DIM(sequence)
w_y <- length(B) / DIM(sequence)
#I <- 0
entr_xy <- 0
entr_x <- 0
entr_y <- 0
# for (i in c(1:5)) {
# if(p_x[i] != 0){
#   I <- I-w_x*p_y[i]*log2(p_x[i])
# }
# if(p_y[i] != 0){
#   I <- I-w_y*p_x[i]*log2(p_y[i])
# }
#   if (p_xy[i] != 0) {
#     entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
#   }
#   if (p_x[i] != 0) {
#     entr_x <- entr_x - p_x[i] * log2(p_x[i])
#   }
#   if (p_y[i] != 0) {
#     entr_y <- entr_y - p_y[i] * log2(p_y[i])
#   }
# }
# I <- entr_xy - w_x * entr_x - w_y * entr_y
#print(paste("I =",I))
for(i in c(1:5)){
if(p_x[i] !=0 ){
I <- I - p_b*p_y[i]*log2(p_x[i])
}
if(p_y[i] != 0){
I <- I - p_a*p_x[i]*log2(p_y[i])
}
}
return(I)
}
infotree <- function(sequence) {
#input:
# sequence -- matrix of characters
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
l = DIM(sequence)
names = row.names(sequence)
if (l == 1) {
tree_string <- names[1]
} else if (l == 2) {
tree_string <- paste("(", names[1], ", ", names[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(l)[2, ])
I <- 0
for (j in 1:dim(sequence)[2]) {
#print(paste("I =",I))
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for (i in 3:(2 ^ (l - 1))) {
# Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(l)[i, ])
for (j in 1:dim(sequence)[2]) {
I <- I + mutual_info(partition, sequence, j)
}
print(paste("I =", I))
if (I < max_val) {
max_val <- I
max_part <- partition
}
}
print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part, , drop = FALSE]
right_sequence <- sequence[!max_part, , drop = FALSE]
left_string <- infotree(left_sequence)
right_string <- infotree(right_sequence)
tree_string <-
paste("(", left_string, ", ", right_string, ")", sep = "")
}
return(tree_string)
}
read.nexus.data("coiii.nex")
infotree <- function(sequence) {
#input:
# sequence -- matrix of characters
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
l = DIM(sequence)
names = row.names(sequence)
if (l == 1) {
tree_string <- names[1]
} else if (l == 2) {
tree_string <- paste("(", names[1], ", ", names[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(l)[2, ])
I <- 0
for (j in 1:dim(sequence)[2]) {
#print(paste("I =",I))
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for (i in 3:(2 ^ (l - 1))) {
# Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(l)[i, ])
for (j in 1:dim(sequence)[2]) {
I <- I + mutual_info(partition, sequence, j)
}
print(paste("I =", I))
if (I < max_val) {
max_val <- I
max_part <- partition
}
}
print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part, , drop = FALSE]
right_sequence <- sequence[!max_part, , drop = FALSE]
left_string <- infotree(left_sequence)
right_string <- infotree(right_sequence)
tree_string <-
paste("(", left_string, ", ", right_string, ")", sep = "")
}
return(tree_string)
}
infotree(raw_data)
DIM <- function(A) {
if (class(A)[1] == "matrix") {
size <- dim(A)[1]
} else {
size <- 1
}
return(size)
}
infotree(raw_data)
mutual_info <- function(partition, sequence, pos) {
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
pxy_all <- base.freq(as.DNAbin(sequence[, pos]), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition, pos]
B <- sequence[!partition, pos]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
# Computing weight
#w_x <- length(A)/length(sequence)
#w_y <- length(B)/length(sequence)
w_x <- length(A) / DIM(sequence)
w_y <- length(B) / DIM(sequence)
#I <- 0
entr_xy <- 0
entr_x <- 0
entr_y <- 0
# for (i in c(1:5)) {
# if(p_x[i] != 0){
#   I <- I-w_x*p_y[i]*log2(p_x[i])
# }
# if(p_y[i] != 0){
#   I <- I-w_y*p_x[i]*log2(p_y[i])
# }
#   if (p_xy[i] != 0) {
#     entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
#   }
#   if (p_x[i] != 0) {
#     entr_x <- entr_x - p_x[i] * log2(p_x[i])
#   }
#   if (p_y[i] != 0) {
#     entr_y <- entr_y - p_y[i] * log2(p_y[i])
#   }
# }
# I <- entr_xy - w_x * entr_x - w_y * entr_y
#print(paste("I =",I))
for(i in c(1:5)){
if(p_x[i] !=0 ){
I <- I - w_y*p_y[i]*log2(p_x[i])
}
if(p_y[i] != 0){
I <- I - w_x*p_x[i]*log2(p_y[i])
}
}
return(I)
}
infotree <- function(sequence) {
#input:
# sequence -- matrix of characters
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
l = DIM(sequence)
names = row.names(sequence)
if (l == 1) {
tree_string <- names[1]
} else if (l == 2) {
tree_string <- paste("(", names[1], ", ", names[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(l)[2, ])
I <- 0
for (j in 1:dim(sequence)[2]) {
#print(paste("I =",I))
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for (i in 2:(2 ^ (l - 1))) {
# Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(l)[i, ])
for (j in 1:dim(sequence)[2]) {
I <- I + mutual_info(partition, sequence, j)
}
print(paste("I =", I))
if (I < max_val) {
max_val <- I
max_part <- partition
}
}
print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part, , drop = FALSE]
right_sequence <- sequence[!max_part, , drop = FALSE]
left_string <- infotree(left_sequence)
right_string <- infotree(right_sequence)
tree_string <-
paste("(", left_string, ", ", right_string, ")", sep = "")
}
return(tree_string)
}
infotree(raw_data)
mutual_info <- function(partition, sequence, pos) {
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
pxy_all <- base.freq(as.DNAbin(sequence[, pos]), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition, pos]
B <- sequence[!partition, pos]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
# Computing weight
#w_x <- length(A)/length(sequence)
#w_y <- length(B)/length(sequence)
w_x <- length(A) / DIM(sequence)
w_y <- length(B) / DIM(sequence)
I <- 0
entr_xy <- 0
entr_x <- 0
entr_y <- 0
# for (i in c(1:5)) {
# if(p_x[i] != 0){
#   I <- I-w_x*p_y[i]*log2(p_x[i])
# }
# if(p_y[i] != 0){
#   I <- I-w_y*p_x[i]*log2(p_y[i])
# }
#   if (p_xy[i] != 0) {
#     entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
#   }
#   if (p_x[i] != 0) {
#     entr_x <- entr_x - p_x[i] * log2(p_x[i])
#   }
#   if (p_y[i] != 0) {
#     entr_y <- entr_y - p_y[i] * log2(p_y[i])
#   }
# }
# I <- entr_xy - w_x * entr_x - w_y * entr_y
#print(paste("I =",I))
for(i in c(1:5)){
if(p_x[i] !=0 ){
I <- I - w_y*p_y[i]*log2(p_x[i])
}
if(p_y[i] != 0){
I <- I - w_x*p_x[i]*log2(p_y[i])
}
}
return(I)
}
infotree(raw_data)
mutual_info <- function(partition, sequence, pos) {
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
pxy_all <- base.freq(as.DNAbin(sequence[, pos]), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition, pos]
B <- sequence[!partition, pos]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
# Computing weight
#w_x <- length(A)/length(sequence)
#w_y <- length(B)/length(sequence)
w_x <- length(A) / DIM(sequence)
w_y <- length(B) / DIM(sequence)
I <- 0
entr_xy <- 0
entr_x <- 0
entr_y <- 0
for (i in c(1:5)) {
if(p_x[i] != 0){
I <- I-w_x*p_y[i]*log2(p_x[i])
}
if(p_y[i] != 0){
I <- I-w_y*p_x[i]*log2(p_y[i])
}
if (p_xy[i] != 0) {
entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
}
if (p_x[i] != 0) {
entr_x <- entr_x - p_x[i] * log2(p_x[i])
}
if (p_y[i] != 0) {
entr_y <- entr_y - p_y[i] * log2(p_y[i])
}
}
I <- entr_xy - w_x * entr_x - w_y * entr_y
#print(paste("I =",I))
#   for(i in c(1:5)){
# if(p_x[i] !=0 ){
#   I <- I - w_y*p_y[i]*log2(p_x[i])
# }
# if(p_y[i] != 0){
#   I <- I - w_x*p_x[i]*log2(p_y[i])
# }
}
return(I)
