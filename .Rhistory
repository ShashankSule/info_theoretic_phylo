trr[[1]]
names(trr)
trr$names
trr[[1]]$names
trr <- rtreeshape(1,9,model = "yule")
trr[[1]]$names <- paste("tip", 1:9, sep = "")
plot(as.phylo(trr[[1]]))
trr_sequence <- as.character(simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA"))
image(as.DNAbin.character(trr_sequence))
div_tree <- infotree(trr_sequence)
agg_tree <- agg_clustering(trr_sequence)
plot(trr[[1]])
title("Original")
trr <- rtreeshape(1,9,model = "yule")
trr[[1]]$names <- paste("tip", 1:9, sep = "")
plot(as.phylo(trr[[1]]))
trr_sequence <- as.character(simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA"))
image(as.DNAbin.character(trr_sequence))
div_tree <- infotree(trr_sequence)
agg_tree <- agg_clustering(trr_sequence)
plot(as.phylo(trr[[1]]))
title("Original")
plot(trr[[1]])
title("Original")
plot(trr[[1]])
title("Original")
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(div_tree, ";", sep = "")))
title("Divisive tree")
plot(read.tree(text = paste(agg_tree, ";", sep = "")))
title("Agglomerative tree")
plot(trr[[1]])
title("Original")
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(div_tree, ";", sep = "")))
title("Divisive tree")
plot(read.tree(text = paste(agg_tree, ";", sep = "")))
title("Agglomerative tree")
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(div_tree, ";", sep = "")))
title("Divisive tree")
plot(read.tree(text = paste(agg_tree, ";", sep = "")))
title("Agglomerative tree")
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
#source("utilities.R")
library("ggplot2")
library("phyclust")
library("TreeDist")
library("TreeTools")
library("dplyr")
# mutual_info <- function(partition, sequence, pos) {
#   # inputs:
#   # partition -- boolean denoting the partitions
#   # sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
#   # pos -- integer denoting the position in the sequence
#   # output:
#   # I(partition)
#   #computing p(x \oplus y)
#
#   pxy_all <- base.freq(as.DNAbin(sequence[, pos]), all = TRUE)
#   p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
#
#   A <- sequence[partition, pos]
#   B <- sequence[!partition, pos]
#
#   # Computing p(x)
#   px_all <- base.freq(as.DNAbin(A), all = TRUE)
#   p_x <- px_all[c("a", "c", "g", "t", "-")]
#
#   # Computing p(y)
#   py_all <- base.freq(as.DNAbin(B), all = TRUE)
#   p_y <- py_all[c("a", "c", "g", "t", "-")]
#
#   # Computing weight
#   #w_x <- length(A)/length(sequence)
#   #w_y <- length(B)/length(sequence)
#   w_x <- length(A) / DIM(sequence)
#   w_y <- length(B) / DIM(sequence)
#
#   I <- 0
#   entr_xy <- 0
#   entr_x <- 0
#   entr_y <- 0
#   for (i in c(1:5)) {
#
#      if (p_xy[i] != 0) {
#        entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
#      }
#      if (p_x[i] != 0) {
#        entr_x <- entr_x - p_x[i] * log2(p_x[i])
#      }
#      if (p_y[i] != 0) {
#        entr_y <- entr_y - p_y[i] * log2(p_y[i])
#      }
#    }
#   I <- entr_xy - w_x * entr_x - w_y * entr_y
#   #print(paste("I =",I))
#
#   #   for(i in c(1:5)){
#   # if(p_x[i] !=0 ){
#   #   I <- I - w_y*p_y[i]*log2(p_x[i])
#   # }
#   # if(p_y[i] != 0){
#   #   I <- I - w_x*p_x[i]*log2(p_y[i])
#   # }
#
#
#   return(I)
# }
info_gain <- function(sequence, partition) {
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
pxy_all <- base.freq(as.DNAbin(sequence), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition]
B <- sequence[!partition]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
# Computing weight
#w_x <- length(A)/length(sequence)
#w_y <- length(B)/length(sequence)
w_x <- length(A) / length(sequence)
w_y <- length(B) / length(sequence)
I <- 0
entr_xy <- 0
entr_x <- 0
entr_y <- 0
for (i in c(1:5)) {
if (p_xy[i] != 0) {
entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
}
if (p_x[i] != 0) {
entr_x <- entr_x - p_x[i] * log2(p_x[i])
}
if (p_y[i] != 0) {
entr_y <- entr_y - p_y[i] * log2(p_y[i])
}
}
I <- entr_xy - w_x * entr_x - w_y * entr_y
#print(paste("I =",I))
#   for(i in c(1:5)){
# if(p_x[i] !=0 ){
#   I <- I - w_y*p_y[i]*log2(p_x[i])
# }
# if(p_y[i] != 0){
#   I <- I - w_x*p_x[i]*log2(p_y[i])
# }
return(I)
}
mutual_info <- function(sequence, partition) {
pxy_all <- base.freq(as.DNAbin(sequence), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition]
B <- sequence[!partition]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
entr_xy <- 0
entr_x <- 0
entr_y <- 0
for (i in c(1:5)) {
if (p_xy[i] != 0) {
entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
}
if (p_x[i] != 0) {
entr_x <- entr_x - p_x[i] * log2(p_x[i])
}
if (p_y[i] != 0) {
entr_y <- entr_y - p_y[i] * log2(p_y[i])
}
}
VI <- 2*entr_xy - entr_x - entr_y
return(VI)
}
DIM <- function(A) {
if (class(A)[1] == "matrix") {
size <- dim(A)[1]
} else {
size <- 1
}
return(size)
}
max_info <- function(partition, seq) {
part_line <- as.logical(partition)
I <- c(0,0)
I <- sum(apply(seq, 2, info_gain, partition = part_line))
print(paste("I =", I))
return(I)
}
max_branch <- function(partition, seq) {
part_line <- as.logical(partition)
I <- c(0,0)
I <- sum(apply(seq, 2, mutual_info, partition = part_line))
print(paste("IG =", I))
return(I)
}
infotree <- function(sequence) {
#input:
# sequence -- matrix of characters
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
l = DIM(sequence)
names = row.names(sequence)
if (l == 1) {
tree_string <- names[1]
} else if (l == 2) {
part_matrix <- splitset(l)[c(2:(2 ^ (l - 1))), ]
branch <- mutual_info(sequence, part_matrix)
tree_string <-
paste("(", names[1], ":", branch/2, ", ", names[2], ":", branch/2, ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
# par <- as.logical(splitset(l)[2, ])
# # I <- 0
# # for (j in 1:dim(sequence)[2]) {
# #   #print(paste("I =",I))
# #   I <- I + mutual_info(partition, sequence, j)
# #
# # }
# max_val <- sum(apply(sequence, 2, mutual_info, partition = par))
# max_part <- par
# for (i in 2:(2 ^ (l - 1))) {
#   # Run through all possible partitions
#   I <- 0
#   # Compute overall mutual information
#   #print(paste("computing the ",i,"th partition"))
#   par <- as.logical(splitset(l)[i, ])
#
#   # for (j in 1:dim(sequence)[2]) {
#   #   I <- I + mutual_info(partition, sequence, j)
#   # }
#   I <- sum(apply(sequence, 2, mutual_info, partition = par))
#
#   print(paste("I =", I))
#
#   if (I > max_val) {
#     max_val <- I
#     max_part <- par
#   }
# }
part_matrix <- splitset(l)[c(2:(2 ^ (l - 1))), ]
res <- apply(part_matrix, 1, max_info, seq = sequence)
inf <- apply(part_matrix, 1, max_branch, seq = sequence)
max_val <- max(res)
max_part <- part_matrix[which.max(res), ]
branch <- inf[which.max(res)]
cur_partition <- as.logical(max_part)
print(paste("The partition is ", cur_partition))
left_sequence <- sequence[cur_partition, , drop = FALSE]
right_sequence <- sequence[!cur_partition, , drop = FALSE]
left_string <- infotree(left_sequence)
right_string <- infotree(right_sequence)
tree_string <-
paste("(", left_string, ":", branch/2, ", ", right_string, ":", branch/2, ")", sep = "")
}
return(tree_string)
}
getwd()
setwd("/Users/shashanksule/Documents/info_theoretic_phylo/")
system("ls")
raw_data <- ReadCharacters("coiii.nex")
infotree(raw_data)
treestring <- "((((Mouse:0.970106687610123, Rat:0.970106687610123):145.015308487661, Seal:145.015308487661):93.7435519103789, (Human:158.11656266226, (Bovine:0.978346159541024, Whale:0.978346159541024):158.11656266226):93.7435519103789):99.8186701552641, (Chicken:175.80499150657, ((Carp:0.982939990908893, Loach:0.982939990908893):151.018566822436, Xenopus:151.018566822436):175.80499150657):99.8186701552641);"
plot(read.tree(text = treestring))
source("utilities.R")
who_dat(sites = 1000, model = 6, parameters = "5 5", gamma = "0.5 4")
trees <- list()
sequences <- list()
for(i in 1:10){
who_dat(sites = 1000,
model = 6,
parameters = "5 5",
gamma = "0.5 4",
equilibrium = "0.25 0.28 0.34 0.13")
system("paml4.8/src/evolverRandomTree 5 paml4.8/MCbaseRTree.dat")
trees[[i]] <- write.tree(read.nexus("mctrees.nex"))
sequences[[i]] <- ReadCharacters("mc.nex")
}
trees
trials <- c(1:10)
divisive <- lapply(lapply(sequences, infotree), function(x) paste(x,";", sep = ""))
agglomerative <- lapply(lapply(sequences, agg_clustering), function(x) paste(x,";", sep = ""))
data <- data.frame(as.character(trees), as.character(divisive), as.character(agglomerative))
div_distance  <- mapply(RobinsonFoulds,
lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
lapply(data$as.character.divisive., function(x) read.tree(text = as.character(x))))
agg_distance <- mapply(RobinsonFoulds,
lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
lapply(data$as.character.agglomerative., function(x) read.tree(text = as.character(x))))
diagnostics <- data.frame(as.character(div_distance), as.character(agg_distance))
div_mean <- diagnostics$as.character.div_distance. %>%
as.character() %>%
as.numeric() %>%
mean()
agg_mean <- diagnostics$as.character.agg_distance. %>%
as.character() %>%
as.numeric() %>%
mean()
print(paste("Average distance of divisive trees from original: ", div_mean, sep = ""))
print(paste("Average distance of agglomerative trees from original: ", agg_mean, sep = ""))
trees <- list()
sequences <- list()
for(i in 1:100){
who_dat(sites = 1000,
model = 6,
parameters = "5 5",
gamma = "0.5 4",
equilibrium = "0.25 0.28 0.34 0.13")
system("paml4.8/src/evolverRandomTree 5 paml4.8/MCbaseRTree.dat")
trees[[i]] <- write.tree(read.nexus("mctrees.nex"))
sequences[[i]] <- ReadCharacters("mc.nex")
}
trials <- c(1:100)
divisive <- lapply(lapply(sequences, infotree), function(x) paste(x,";", sep = ""))
trials <- c(1:100)
divisive <- lapply(lapply(sequences, infotree), function(x) paste(x,";", sep = ""))
trials <- c(1:100)
divisive <- lapply(lapply(sequences, infotree), function(x) paste(x,";", sep = ""))
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("phyclust")
library("TreeDist")
library("TreeTools")
library("dplyr")
trials <- c(1:100)
divisive <- lapply(lapply(sequences, infotree), function(x) paste(x,";", sep = ""))
agglomerative <- lapply(lapply(sequences, agg_clustering), function(x) paste(x,";", sep = ""))
divisive
agglomerative
data <- data.frame(as.character(trees), as.character(divisive), as.character(agglomerative))
div_distance  <- mapply(RobinsonFoulds,
lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
lapply(data$as.character.divisive., function(x) read.tree(text = as.character(x))))
agg_distance <- mapply(RobinsonFoulds,
lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
lapply(data$as.character.agglomerative., function(x) read.tree(text = as.character(x))))
diagnostics <- data.frame(as.character(div_distance), as.character(agg_distance))
div_mean <- diagnostics$as.character.div_distance. %>%
as.character() %>%
as.numeric() %>%
mean()
agg_mean <- diagnostics$as.character.agg_distance. %>%
as.character() %>%
as.numeric() %>%
mean()
print(paste("Average distance of divisive trees from original: ", div_mean, sep = ""))
print(paste("Average distance of agglomerative trees from original: ", agg_mean, sep = ""))
View(data)
View(diagnostics)
View(diagnostics)
?is.ultrametric
is.ultrametric(read.tree(text = "((S1:0.968128409288215, S3:0.968128409288215):304.248936737962, ((S2:0.969761903930693, S4:0.969761903930693):429.052687929088, S5:429.052687929088):304.248936737962);	"))
ultrameasure[] <- lapply(data, function(x) is.ultrametric(read.tree(text = as.character(x))))
6400*12
plot(read.tree(text = "((S1:0.968128409288215, S3:0.968128409288215):304.248936737962, ((S2:0.969761903930693, S4:0.969761903930693):429.052687929088, S5:429.052687929088):304.248936737962);	"))
metricity <- data
metricity[] <- lapply(metricity, function(x) is.ultrametric(read.tree(text = as.character(x))))
metricity
as.numeric(TRUE)
metricity[] <- metricity %>%
lapply(function(x) is.ultrametric(read.tree(text = as.character(x)))) %>%
as.numeric()
metricity[] <- metricity %>%
lapply(function(x) is.ultrametric(dist.dna(read.tree(text = as.character(x))))) %>%
as.numeric()
is.ultrametric(read.tree(text = "(((S5:0.938262,S1:0.938262):0.127219,(S4:0.964427,S2:0.964427):0.101054):0.43452,S3:1.5)-;"))
metricity[] <- metricity %>%
lapply(function(x) is.ultrametric(read.tree(text = as.character(x))))
View(metricity)
metricity <- data
metricity[] <- metricity %>%
lapply(function(x) is.ultrametric(read.tree(text = as.character(x))))
summary(metricity)
nj_trees <- sequences %>%
lapply(as.DNAbin()) %>%
lapply(dist.dna()) %>%
lapply(nj())
sequences[[1]]
as.DNAbin(sequence[[1]])
class(as.DNAbin(sequence[[1]]))
class(sequence[[1]])
class(sequences[[1]])
as.DNAbin(sequences[[1]])
lapply(sequences, as.DNAbin())
lapply(sequences, function(x) as.DNAbin(x))
nj_trees <- sequences %>%
lapply(as.DNAbin) %>%
lapply(dist.dna %>%
lapply(nj)
nj_trees <- sequences %>%
lapply(as.DNAbin) %>%
lapply(dist.dna) %>%
lapply(nj)
summary(nj_trees)
write.tree(nj_trees[1,])
nj_trees[1,]
View(nj_trees)
View(nj_trees)
nj_trees[[1]]
write.tree(nj_trees)
write.tree(nj_trees[[1]])
nj_trees <- sequences %>%
lapply(as.DNAbin) %>%
lapply(dist.dna) %>%
lapply(nj) %>%
lapply(write.tree)
View(nj_trees)
View(nj_trees)
data <- data.frame(as.character(trees), as.character(divisive), as.character(agglomerative),
as.character(nj_trees))
nj_distance <- mapply(RobinsonFoulds,
lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
lapply(data$as.character.nj., function(x) read.tree(text = as.character(x))))
View(data)
View(data)
nj_distance <- mapply(RobinsonFoulds,
lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
lapply(data$as.character.nj_trees., function(x) read.tree(text = as.character(x))))
diagnostics <- data.frame(as.character(div_distance),
as.character(agg_distance),
as.character(nj_distance))
nj_mean <-  diagnostics$as.character.nj_distance. %>%
as.character() %>%
as.numeric() %>%
mean()
div_mean <- diagnostics$as.character.div_distance. %>%
as.character() %>%
as.numeric() %>%
mean()
agg_mean <- diagnostics$as.character.agg_distance. %>%
as.character() %>%
as.numeric() %>%
mean()
nj_mean <-  diagnostics$as.character.nj_distance. %>%
as.character() %>%
as.numeric() %>%
mean()
print(paste("Average distance of divisive trees from original: ", div_mean, sep = ""))
print(paste("Average distance of agglomerative trees from original: ", agg_mean, sep = ""))
print(paste("Average distance of NJ trees from original: ", nj_mean, sep = ""))
metricity <- data
metricity[] <- metricity %>%
lapply(function(x) is.ultrametric(read.tree(text = as.character(x))))
summary(metricity)
?is.ultrametric
low_metricity <- data
low_metricity[] <- low_metricity %>%
lapply(function(x) is.ultrametric(read.tree(text = as.character(x)), tol = 1e-2))
View(low_metricity)
low_metricity <- data
low_metricity[] <- low_metricity %>%
lapply(function(x) is.ultrametric(read.tree(text = as.character(x)), tol = 1e-2))
summary(low_metricity)
knitr::opts_chunk$set(include = FALSE)
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("phyclust")
library("TreeDist")
library("TreeTools")
library("dplyr")
summary(low_metricity)
