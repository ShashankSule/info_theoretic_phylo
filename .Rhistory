}
seqs[1:2,]
#infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
sequence <- seqs[1:2,]
# if there are only two sequences return dichotomous tree
if(length(sequence) == 2){
tree_string <- paste("(", names(seqs)[1], ", ", names(seqs)[2], ")", sep = "")
}else{
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 1:2^length(sequence)){
# Compute overall mutual information
I <- 0
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
left_sequence <- sequence[partition,]
right_sequence <- sequence[!partition,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
#}
tree_string
length(seqs)
#infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
sequence <- seqs
# if there are only two sequences return dichotomous tree
if(length(sequence) == 2){
tree_string <- paste("(", names(seqs)[1], ", ", names(seqs)[2], ")", sep = "")
}else{
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 1:2^length(sequence)){
# Compute overall mutual information
I <- 0
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
left_sequence <- sequence[partition,]
right_sequence <- sequence[!partition,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
seqs[rep(FALSE,9),]
mutual_info(rep(FALSE,9),seqs, 1)
mutual_info(!rep(FALSE,9),seqs, 1)
base.freq(as.DNAbin(seqs[rep(FALSE,9),]))
splitset(4)[1,]
all(as.logical(splitset(4)[1,]))
all(as.logical(splitset(4)[2,]))
splitset(3)
#infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
sequence <- seqs
# if there are only two sequences return dichotomous tree
if(length(sequence) == 2){
tree_string <- paste("(", names(seqs)[1], ", ", names(seqs)[2], ")", sep = "")
}else{
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 1:2^length(sequence)){ # Run through all possible partitions
I <- 0
if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
left_sequence <- sequence[partition,]
right_sequence <- sequence[!partition,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
#infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
sequence <- seqs
# if there are only two sequences return dichotomous tree
if(length(sequence) == 2){
tree_string <- paste("(", names(seqs)[1], ", ", names(seqs)[2], ")", sep = "")
}else{
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
left_sequence <- sequence[partition,]
right_sequence <- sequence[!partition,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
#}
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(seqs, "nr")){
I <- I + mutual_info(partition, seqs, j)
}
#infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
sequence <- seqs
# if there are only two sequences return dichotomous tree
if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
}else{
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
left_sequence <- sequence[partition,]
right_sequence <- sequence[!partition,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
# Computing p(x,y)
p_xy <- matrix(nrow = 4, ncol = 4)
prod <- as.data.frame(expand.grid(A,B)) # Stores cartesian products of the A and B data
for(i in c(1:4)){
for (j in c(1:4)) {
counter <- 0  # Counter that stores how many times we hit a given pair (x,y)
# Subroutine that does the counting: k runs through all the rows of prod
for (k in 1:nrow(prod)){
if(all(prod[k,] == c(i,j))){
counter <- counter + 1
}
}
p_xy[i,j] <- counter/nrow(prod)
}
}
I <- 0
for(i in c(1:4)){
for(j in c(1:4)){
if(p_x[i]*p_y[j] != 0){
I <- I + p_xy[i,j]*log2(p_xy[i,j]/(p_x[i]*p_y[j]))
}
}
}
return(I)
}
#infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
sequence <- seqs
# if there are only two sequences return dichotomous tree
if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
}else{
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
left_sequence <- sequence[partition,]
right_sequence <- sequence[!partition,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
# Computing p(x,y)
p_xy <- matrix(nrow = 4, ncol = 4)
prod <- as.data.frame(expand.grid(A,B)) # Stores cartesian products of the A and B data
for(i in c(1:4)){
for (j in c(1:4)) {
counter <- 0  # Counter that stores how many times we hit a given pair (x,y)
# Subroutine that does the counting: k runs through all the rows of prod
for (k in 1:nrow(prod)){
if(all(prod[k,] == c(i,j))){
counter <- counter + 1
}
}
p_xy[i,j] <- counter/nrow(prod)
}
}
I <- 0
for(i in c(1:4)){
for(j in c(1:4)){
if(p_x[i]*p_y[j] != 0){
I <- I + p_xy[i,j]*log2(p_xy[i,j]/(p_x[i]*p_y[j]))
}
}
}
return(I)
}
sequence <- seqs
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
}else{
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
left_sequence <- sequence[partition,]
right_sequence <- sequence[!partition,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
}
infopart(seqs)
t <- rtreeshape(1,9,model = "yule")
plot(as.phylo(t[[1]]))
seqs <- simSeq(as.phylo(t[[1]]),l=12)
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
getwd()
source("utilities.R")
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
sequence <- seqs
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
# Computing p(x,y)
p_xy <- matrix(nrow = 4, ncol = 4)
prod <- as.data.frame(expand.grid(A,B)) # Stores cartesian products of the A and B data
for(i in c(1:4)){
for (j in c(1:4)) {
counter <- 0  # Counter that stores how many times we hit a given pair (x,y)
# Subroutine that does the counting: k runs through all the rows of prod
for (k in 1:nrow(prod)){
if(all(prod[k,] == c(i,j))){
counter <- counter + 1
}
}
p_xy[i,j] <- counter/nrow(prod)
}
}
I <- 0
for(i in c(1:4)){
for(j in c(1:4)){
if(p_x[i]*p_y[j] != 0){
I <- I + p_xy[i,j]*log2(p_xy[i,j]/(p_x[i]*p_y[j]))
}
}
}
return(I)
}
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
#if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
# Compute overall mutual information
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
seqs[,3]
seqs[,1:4]
sequence <- seqs[,1:4]
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
length(sequence)
sequence <- seqs[1:4,]
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
if(I > max_val){
max_val <- I
max_part <- partition
}
}
# There are more than two sequences so we must find the optimal partition
max_val <- 0
max_part <- logical(length = length(sequence))
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
print(paste("I =",I))
if(I > max_val){
max_val <- I
max_part <- partition
}
}
attr(sequence,"nr")
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
partition <- c(TRUE, TRUE, FALSE, FALSE)
mutual_info(partition, sequence, j)
