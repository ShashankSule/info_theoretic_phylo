mutual_info <- function(partition, sequence, pos, J = "ce"){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
p_xy <- base.freq(as.DNAbin(sequence))
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
p_a <- length(A)/length(sequence)
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
p_b <- length(B)/length(sequence)
# Computing p(x,y)
I <- 0
for(i in c(1:4)){
if(J == "ce"){
#cross entropy
if(p_y[i] == 0){
y_term = 0
} else{
y_term = -p_x[i]*log2(p_y[i])
}
if(p_x[i] == 0){
x_term = 0
} else {
x_term = -p_y[i]*log2(p_x[i])
}
I <- I + x_term + y_term
}
if(J == "ig"){
#information gain
if(p_y[i] == 0){
y_term = 0
} else{
y_term = -p_y[i]*log2(p_y[i])
}
if(p_x[i] == 0){
x_term = 0
} else {
x_term = -p_x[i]*log2(p_x[i])
}
if(p_xy[i] == 0){
xy_term = 0
} else {
xy_term = -p_xy[i]*log2(p_xy[i])
}
I <- I + xy_term - p_a*x_term - p_b*y_term
}
}
return(I)
}
infopart <- function(sequence, J = "ce"){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j, J)
}
#print(paste("I =",I))
if(I > max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
infopart <- function(sequence, J = "ce"){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j, J)
}
#print(paste("I =",I))
if(I > max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
IG_tree_string <- paste(infopart(seqs, J="ig"), ";", sep="")
IG_tree_string
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
p_xy <- base.freq(as.DNAbin(sequence))
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
p_a <- length(A)/length(sequence)
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
p_b <- length(B)/length(sequence)
h_xy <- 0
h_x <- 0
h_y <- 0
# Computing p(x,y)
I <- 0
for(i in c(1:4)){
if(p_xy[i] !=0){
h_xy <- h_xy -p_xy[i]*log2(p_xy[i])
}
if(p_x[i] != 0){
h_x <- h_x -p_x[i]*log2(p_x[i])
}
if(p_y[i] != 0){
h_y <- h_y -p_y[i]*log2(p_y[i])
}
}
I <- h_xy - p_a*h_x - p_b*h_y
return(I)
}
infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^(length(sequence))-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#print(paste("I =",I))
if(I > max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
paste(infopart(seqs), ";", sep="")
plot(read.tree(text = "(((tip 1, (tip 3, tip 5)), tip 6), ((tip 4, tip 8), (tip 2, (tip 7, tip 9))));"))
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
p_xy <- base.freq(as.DNAbin(sequence))
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
p_a <- length(A)/length(sequence)
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
p_b <- length(B)/length(sequence)
h_xy <- 0
h_x <- 0
h_y <- 0
# Computing p(x,y)
I <- 0
# for(i in c(1:4)){
#   if(p_xy[i] !=0){
#     h_xy <- h_xy -p_xy[i]*log2(p_xy[i])
#   }
#   if(p_x[i] != 0){
#     h_x <- h_x -p_x[i]*log2(p_x[i])
#   }
#   if(p_y[i] != 0){
#     h_y <- h_y -p_y[i]*log2(p_y[i])
#   }
# }
#
# I <- h_xy - p_a*h_x - p_b*h_y
for(i in c(1:4)){
if(p_x[i] !=0 ){
I <- I - p_y[i]*log2(p_x[i])
}
if(p_y[i] != 0){
I <- p_x[i]*log2(p_y[i])
}
}
return(I)
}
infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^(length(sequence))-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#print(paste("I =",I))
if(I < max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
infopart(seqs)
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
t <- rtreeshape(1,9,model = "yule")
plot(as.phylo(t[[1]]))
seqs <- simSeq(as.phylo(t[[1]]),l=1, type = "DNA")
IG_tree_string <- paste(infopart(seqs), ";", sep="")
image(as.DNAbin(seqs))
layout(matrix(c(1,2), 1, 2))
#image(as.DNAbin(seqs))
plot(read.tree(text = IG_tree_string))
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
p_xy <- base.freq(as.DNAbin(sequence))
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
p_a <- length(A)/length(sequence)
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
p_b <- length(B)/length(sequence)
h_xy <- 0
h_x <- 0
h_y <- 0
# Computing p(x,y)
I <- 0
for(i in c(1:4)){
if(p_xy[i] !=0){
h_xy <- h_xy -p_xy[i]*log2(p_xy[i])
}
if(p_x[i] != 0){
h_x <- h_x -p_x[i]*log2(p_x[i])
}
if(p_y[i] != 0){
h_y <- h_y -p_y[i]*log2(p_y[i])
}
}
I <- h_xy - p_a*h_x - p_b*h_y
# for(i in c(1:4)){
#   if(p_x[i] !=0 ){
#     I <- I - p_a*p_y[i]*log2(p_x[i])
#   }
#   if(p_y[i] != 0){
#     I <- I - p_b*p_x[i]*log2(p_y[i])
#   }
# }
return(I)
}
infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^(length(sequence))-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#print(paste("I =",I))
if(I > max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
IG_tree_string <- paste(infopart(seqs), ";", sep="")
image(as.DNAbin(seqs))
layout(matrix(c(1,2), 1, 2))
#image(as.DNAbin(seqs))
plot(read.tree(text = IG_tree_string))
seqs2 <- simSeq(as.phylo(t[[1]]),l=12, type = "DNA")
image(as.DNAbin(seqs))
image(as.DNAbin(seqs2))
IG2_tree_string <- paste(infopart(seqs2), ";", sep="")
plot(read.tree(text = IG_tree_string))
plot(read.tree(text = IG2_tree_string))
?image.phyDat
?image
image(as.DNAbin(seqs))
#layout(matrix(c(1,2), 1, 2))
#image(as.DNAbin(seqs))
plot(read.tree(text = IG_tree_string))
?save.image
save.image(image(as.DNAbin(seqs)))
?save.image
save.image(image(as.DNAbin(seqs)), file = "imagg")
?getwd
getwd()
?chdir
?setwd()
setwd(/Documents/info_theoretic_phylo)
setwd("/Users/shashanksule/Documents/info_theoretic_phylo")
getwd()
aa <- [[1 3 5], [6 7 8]]
?write.dna
?read.dna
codes <- c("cggttgggagct",
"aggtcgtgaggt",
"tggttggggttt",
"tgggtgcgagtt",
"acgtttgggtga",
"aaggttggggaa",
"gtctttcgggtg",
"cacttgcggggg",
"gcgcggtgcagc",
"aggcggtgcggg",
"gggcggggcggg",
"gggcgctgcggg",
"ggacggaggctg",
"aggaggctgatg",
"tggcggatgatg")
class(codes)
?lapply
lapply(s2c, codes)
lapply(codes, s2c)
?write.dna
trial_dna <- write.dna(lapply(codes,s2c))
getwd)()
getwd()
trial_dna <- write.dna(lapply(codes,s2c), file = "press_codes.phy")
read.dna("press_codes.phy")
class(seqs)
read.dna("press_codes.phy")
trial_DNA <- as.phyDat(read.dna("press_codes.phy"))
trial_DNA
codes <- c("cggttgggagct",
"aggtcgtgaggt",
"tggttggggttt",
"tgggtgcgagtt",
"acgtttgggtga",
"aaggttggggaa",
"gtctttcgggtg",
"cacttgcggggg",
"gcgcggtgcagc",
"aggcggtgcggg",
"gggcggggcggg",
"gggcgctgcggg",
"ggacggaggctg",
"gggtgggagctg",
"aggaggctgatg",
"tggcggatgatg")
write.dna(lapply(codes,s2c),"press_codes.phy")
read.dna("press_codes.phy")
trial_DNA <- as.phyDat(read.dna("press_codes.phy"))
trial_DNA
infopart(trial_DNA)
trial_DNA[1:8,]
infopart(trial_DNA[1:8,])
plot(read.tree(text = paste(infopart(trial_DNA), ";", sep="")))
plot(read.tree(text = paste(infopart(trial_DNA[1:8,]), ";", sep="")))
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(infopart(trial_DNA[1:8,]), ";", sep="")))
plot(read.tree(text = paste(infopart(trial_DNA[8:16,]), ";", sep="")))
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(infopart(trial_DNA[1:8,]), ";", sep="")))
plot(read.tree(text = paste(infopart(trial_DNA[9:16,]), ";", sep="")))
