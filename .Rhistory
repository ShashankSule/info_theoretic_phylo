if(p_xy[i] == 0){
xy_term = 0
} else {
xy_term = -p_xy[i]*log2(p_xy[i])
}
I <- I + xy_term - p_a*x_term - p_b*y_term
}
}
return(I)
}
infopart <- function(sequence, J = "ce"){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j, J)
}
#print(paste("I =",I))
if(I > max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
infopart <- function(sequence, J = "ce"){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j, J)
}
#print(paste("I =",I))
if(I > max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
IG_tree_string <- paste(infopart(seqs, J="ig"), ";", sep="")
IG_tree_string
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
p_xy <- base.freq(as.DNAbin(sequence))
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
p_a <- length(A)/length(sequence)
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
p_b <- length(B)/length(sequence)
h_xy <- 0
h_x <- 0
h_y <- 0
# Computing p(x,y)
I <- 0
for(i in c(1:4)){
if(p_xy[i] !=0){
h_xy <- h_xy -p_xy[i]*log2(p_xy[i])
}
if(p_x[i] != 0){
h_x <- h_x -p_x[i]*log2(p_x[i])
}
if(p_y[i] != 0){
h_y <- h_y -p_y[i]*log2(p_y[i])
}
}
I <- h_xy - p_a*h_x - p_b*h_y
return(I)
}
infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^(length(sequence))-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#print(paste("I =",I))
if(I > max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
paste(infopart(seqs), ";", sep="")
plot(read.tree(text = "(((tip 1, (tip 3, tip 5)), tip 6), ((tip 4, tip 8), (tip 2, (tip 7, tip 9))));"))
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
p_xy <- base.freq(as.DNAbin(sequence))
A <- sequence[partition,pos]
B <- sequence[!partition,pos]
# Computing p(x)
p_x <- base.freq(as.DNAbin(A))
p_a <- length(A)/length(sequence)
# Computing p(y)
p_y <- base.freq(as.DNAbin(B))
p_b <- length(B)/length(sequence)
h_xy <- 0
h_x <- 0
h_y <- 0
# Computing p(x,y)
I <- 0
# for(i in c(1:4)){
#   if(p_xy[i] !=0){
#     h_xy <- h_xy -p_xy[i]*log2(p_xy[i])
#   }
#   if(p_x[i] != 0){
#     h_x <- h_x -p_x[i]*log2(p_x[i])
#   }
#   if(p_y[i] != 0){
#     h_y <- h_y -p_y[i]*log2(p_y[i])
#   }
# }
#
# I <- h_xy - p_a*h_x - p_b*h_y
for(i in c(1:4)){
if(p_x[i] !=0 ){
I <- I - p_y[i]*log2(p_x[i])
}
if(p_y[i] != 0){
I <- p_x[i]*log2(p_y[i])
}
}
return(I)
}
infopart <- function(sequence){
#input:
# sequence -- aligned sequence in DNAbin or phyDat
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
if(length(sequence) == 1){
tree_string <- names(sequence)[1]
} else if(length(sequence) == 2){
tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(length(sequence))[2,])
I <- 0
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for(i in 2:(2^(length(sequence))-1)){ # Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(length(sequence))[i,])
for(j in 1:attr(sequence, "nr")){
I <- I + mutual_info(partition, sequence, j)
}
#print(paste("I =",I))
if(I < max_val){
max_val <- I
max_part <- partition
}
}
#print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part,]
right_sequence <- sequence[!max_part,]
left_string <- infopart(left_sequence)
right_string <- infopart(right_sequence)
tree_string <- paste("(",left_string,", ",right_string,")", sep = "")
}
return(tree_string)
}
infopart(seqs)
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
trials <- as.phyDat(read.nexus.data("coiii.nex"),
type = "USER",
levels = c("a","c","g","t","-"),
all = TRUE)
trials <- read.nexus.data("coiii.nex", all = TRUE)
trials <- read.nexus.data("coiii.nex")
seqx <- trials[1:5]
seqy <- trials[6:10]
seqx
base.freq(seqx)
trials <- as.DNAbin(read.nexus.data("coiii.nex"), all = TRUE)
seqx <- trials[1:5]
seqy <- trials[6:10]
base.freq(seqx)
base.freq(seqx, all = TRUE)
base.freq(seqy, all = TRUE)
base.freq(seqy[1,], all = TRUE)
seqy[1]
seqy[1:2]
attributes(seqy)
seqy[names(seqy)][1:1]
seqy[names(seqy)]
seqy[names(seqy)][1:85]
raw_data <- ReadCharacters("coiii.nex")
library(TreeTools)
raw_data <- ReadCharacters("coiii.nex")
setwd("/Users/shashanksule/Documents/info_theoretic_phylo/")
rownames(raw_data) <- names(as.DNAbin(read.nexus.data("coiii.nex")))
names(raw_data)
rownames(raw_data)
raw_data["Bovine"]
raw_data["Bovine",]
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("TreeTools")
trials <- ReadCharacters("coiii.nex")
rownames(trials) <- names(as.DNAbin(read.nexus.data("coiii.nex")))
View(raw_data)
remove(raw_data)
seqx <- trials[1:5,]
seqy <- trials[6:10,]
rownames(seqy)
as.DNAbin(seqx[,1])
seqx[,1]
seqx[,1:2]
as.DNAbin(seqx[,1:2])
matrix(seqx[,1], nrow = nrow(seqx), ncol = 1)
matrix(seqx[,1], nrow = nrow(seqx), ncol = 1, rownames = rownames(seqx))
matrix(seqx[,1], nrow = nrow(seqx), ncol = 1)
#alg_info <- function(seqx, seqy){
n <- dim(seqx)[2] # stores number of sites
I_alg <- 0
for(j in 1:n){
# compute the algorithmic mutual information between two sequences at one site
pxy_all <- base.freq(as.DNAbin(c(seqx[,j],seqy[,j])), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
px_all <- base.freq(as.DNAbin(seqx[,j]), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(seqy[,j]), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
entr_xy <- 0
entr_x <- 0
entr_y <- 0
I_alg_site <- 0
for(i in c(1:5)){
if(p_xy[i] != 0){
entr_xy <- entr_xy - p_xy[i]*log2(p_xy[i])
}
if(p_x[i] != 0){
entr_x <- entr_x - p_x[i]*log2(p_x[i])
}
if(p_y[i] != 0){
entr_y <- entr_y - p_y[i]*log2(p_y[i])
}
}
I_alg_site <- entr_x + entr_y - entr_xy
I_alg <- I_alg + I_alg_site
}
#   return(I_alg)
# }
make_newick(c("Hello","World"))
make_newick(paste("(Hello)",",","(World)"))
sequence <- trials
rownames(sequence)
#agg_clustering <- function(sequence){
#inputs:
# sequence -- aligned dna sequence in phyDat
#ouput:
# tree in newick format
forests <- lapply(rownames(sequence),make_newick)
if(length(forests) == 1){
# Just one species
tree_string <- forests[1]
} else if(length(forests == 2)){
# Just two species
tree_string <- make_newick(paste(forests[1],",",forests[2],sep = ""))
} else{
#More than two species
end <- length(forests) - 2
for(i in c(1:end)){ #Do this subroutine n-2 times!
max_dist <- alg_info(sequence[read.tree(text = forests[1])$tip.label,],
sequence[read.tree(text = forests[2])$tip.label,])
max_pair <- c(i,j)
#Subroutine for computing the closest two clusters
for(k in c(1:length(forests))){
for(j in c( (k+1):length(forests) )){
dist <- alg_info(sequence[read.tree(text = forests[k])$tip.label],
sequence[read.tree(text = forests[j])$tip.label])
if(dist > max_dist){
max_dist <- dist
max_pair <- c(k,j)
}
}
}
#Subroutine for joining the two forests
new_branch <- make_newick(forests[max_pair])
forests[- max_pair]
forests <- c(forests,new_branch)
}
tree_string <- make_newick(paste(forests[1],",",forests[2],sep = ""))
}
#}
source("utilities.R")
forests <- lapply(rownames(sequence),make_newick)
end <- length(forests) - 2
read.tree(text = forests[1])$tip.label
forests[1]
class(forests[1])
class(forests[1][[1]])
forests <- make_newick(rownames(sequence))
forests
class(forests)
forests[1]
class(forests[1])
read.tree(text = forests[1])$tip.label
read.tree(text = forests[1])
trr <- read.tree(text = forests[1])
trr
trr <- read.tree(text = paste(forests[1],";",sep = ""))
trr
read.tree(text = paste(forests[1],";",sep=""))$tip.label
alg_info(sequence["Bovine",], sequene["Human",])
alg_info <- function(seqx, seqy){
n <- dim(seqx)[2] # stores number of sites
I_alg <- 0
for(j in 1:n){
# compute the algorithmic mutual information between two sequences at one site
pxy_all <- base.freq(as.DNAbin(c(seqx[,j],seqy[,j])), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
px_all <- base.freq(as.DNAbin(seqx[,j]), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(seqy[,j]), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
entr_xy <- 0
entr_x <- 0
entr_y <- 0
I_alg_site <- 0
for(i in c(1:5)){
if(p_xy[i] != 0){
entr_xy <- entr_xy - p_xy[i]*log2(p_xy[i])
}
if(p_x[i] != 0){
entr_x <- entr_x - p_x[i]*log2(p_x[i])
}
if(p_y[i] != 0){
entr_y <- entr_y - p_y[i]*log2(p_y[i])
}
}
I_alg_site <- entr_x + entr_y - entr_xy
I_alg <- I_alg + I_alg_site
}
return(I_alg)
}
alg_info(sequence["Bovine",], sequence["Human",])
sequence["Bovine",]
x_names
x_names <- read.tree(text = paste(forests[1],";",sep=""))$tip.label
y_names <- read.tree(text = paste(forests[2],";",sep=""))$tip.label
x_names
sequence[x_names,]
dim(sequence[x_names,])
matrix(sequence[x_names], nrow = length(x_names))
matrix(sequence[x_names,], nrow = length(x_names))
max_dist <- alg_info(matrix(sequence[x_names,],nrow = length(x_names)),
matrix(sequence[y_names,],nrow = length(y_names)))
max_dist
length(forests)
for(k in c(1:length(forests))){
for(j in c( (k+1):length(forests) )){
x_names <- read.tree(text = paste(forests[k],";",sep=""))$tip.label
y_names <- read.tree(text = paste(forests[j],";",sep=""))$tip.label
dist <- alg_info(matrix(sequence[x_names,],nrow = length(x_names)),
matrix(sequence[y_names,],nrow = length(y_names)))
if(dist > max_dist){
max_dist <- dist
max_pair <- c(k,j)
}
}
}
for(k in 1:(length(forests)-1) ){
for(j in (k+1):length(forests) ){
x_names <- read.tree(text = paste(forests[k],";",sep=""))$tip.label
y_names <- read.tree(text = paste(forests[j],";",sep=""))$tip.label
dist <- alg_info(matrix(sequence[x_names,],nrow = length(x_names)),
matrix(sequence[y_names,],nrow = length(y_names)))
if(dist > max_dist){
max_dist <- dist
max_pair <- c(k,j)
}
}
}
sequence <- sequence[,1:10]
sequence
-210 > 200
sequence <- ReadCharacters("coiii.nex")
rownames(sequence) <- names(as.DNAbin(read.nexus.data("coiii.nex")))
alg_info(matrix(sequence["Bovine",],nrow = length(x_names)),
matrix(sequence["Whale",],nrow = length(y_names)))
names(sequence)[c(2,5)]
rownames(sequence)[c(2,5)]
