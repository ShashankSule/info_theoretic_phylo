trr_sequence <- simSeq(trr[[1]],l=1000, type = "DNA")
?simSeq
class(trr)
trr_sequence <- simSeq(trr,l=1000, type = "DNA")
trr_sequence
t <- rtreeshape(1,9,model = "yule")
plot(as.phylo(t[[1]]))
seqs <- simSeq(as.phylo(t[[1]]),l=12, type = "DNA")
trr < rtreeshape(1,9,model = "yule")
t <- rtreeshape(1,9,model = "yule")
plot(as.phylo(t[[1]]))
trr < rtreeshape(1,9,model = "yule")
trr <- rtreeshape(1,9,model = "yule")
plot(trr)
plot(as.phylo(trr[[1]]))
trr_sequence <- simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA")
N <- dist.dna(as.DNAbin(trr_sequence), model = "JC69")
plot(upgma(N))
trr[[1]]
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("TreeTools")
library("phyclust")
trr <- rtreeshape(1,9,model = "yule")
plot(as.phylo(trr[[1]]))
trr_sequence <- simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA")
mutual_info <- function(partition, sequence, pos) {
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
pxy_all <- base.freq(as.DNAbin(sequence[, pos]), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition, pos]
B <- sequence[!partition, pos]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
# Computing weight
#w_x <- length(A)/length(sequence)
#w_y <- length(B)/length(sequence)
w_x <- length(A) / DIM(sequence)
w_y <- length(B) / DIM(sequence)
I <- 0
entr_xy <- 0
entr_x <- 0
entr_y <- 0
for (i in c(1:5)) {
if (p_xy[i] != 0) {
entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
}
if (p_x[i] != 0) {
entr_x <- entr_x - p_x[i] * log2(p_x[i])
}
if (p_y[i] != 0) {
entr_y <- entr_y - p_y[i] * log2(p_y[i])
}
}
I <- entr_xy - w_x * entr_x - w_y * entr_y
#print(paste("I =",I))
#   for(i in c(1:5)){
# if(p_x[i] !=0 ){
#   I <- I - w_y*p_y[i]*log2(p_x[i])
# }
# if(p_y[i] != 0){
#   I <- I - w_x*p_x[i]*log2(p_y[i])
# }
}
return(I)
mutual_info <- function(partition, sequence, pos) {
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
pxy_all <- base.freq(as.DNAbin(sequence[, pos]), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition, pos]
B <- sequence[!partition, pos]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
# Computing weight
#w_x <- length(A)/length(sequence)
#w_y <- length(B)/length(sequence)
w_x <- length(A) / DIM(sequence)
w_y <- length(B) / DIM(sequence)
I <- 0
entr_xy <- 0
entr_x <- 0
entr_y <- 0
for (i in c(1:5)) {
if (p_xy[i] != 0) {
entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
}
if (p_x[i] != 0) {
entr_x <- entr_x - p_x[i] * log2(p_x[i])
}
if (p_y[i] != 0) {
entr_y <- entr_y - p_y[i] * log2(p_y[i])
}
}
I <- entr_xy - w_x * entr_x - w_y * entr_y
#print(paste("I =",I))
#   for(i in c(1:5)){
# if(p_x[i] !=0 ){
#   I <- I - w_y*p_y[i]*log2(p_x[i])
# }
# if(p_y[i] != 0){
#   I <- I - w_x*p_x[i]*log2(p_y[i])
# }
#}
return(I)
}
DIM <- function(A) {
if (class(A)[1] == "matrix") {
size <- dim(A)[1]
} else {
size <- 1
}
return(size)
}
infotree <- function(sequence) {
#input:
# sequence -- matrix of characters
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
l = DIM(sequence)
names = row.names(sequence)
if (l == 1) {
tree_string <- names[1]
} else if (l == 2) {
tree_string <- paste("(", names[1], ", ", names[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(l)[2, ])
I <- 0
for (j in 1:dim(sequence)[2]) {
#print(paste("I =",I))
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for (i in 2:(2 ^ (l - 1))) {
# Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(l)[i, ])
for (j in 1:dim(sequence)[2]) {
I <- I + mutual_info(partition, sequence, j)
}
print(paste("I =", I))
if (I < max_val) {
max_val <- I
max_part <- partition
}
}
print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part, , drop = FALSE]
right_sequence <- sequence[!max_part, , drop = FALSE]
left_string <- infotree(left_sequence)
right_string <- infotree(right_sequence)
tree_string <-
paste("(", left_string, ", ", right_string, ")", sep = "")
}
return(tree_string)
}
infotree(trr_sequence)
infopart(trr_sequence)
source("utilities.R")
ReadCharacters(trr_sequence)
as.matrix(trr_sequence)
trr_sequence2 <- as.matrix(trr_sequence)
trr_sequence[,]
attributes(trr_sequence)
as.character(trr_sequence)
trr_sequence2 <- as.character(trr_sequence)
names(trr_sequence2)
rownames(trr_sequence2)
mutual_info <- function(partition, sequence, pos) {
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence
# output:
# I(partition)
#computing p(x \oplus y)
pxy_all <- base.freq(as.DNAbin(sequence[, pos]), all = TRUE)
p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
A <- sequence[partition, pos]
B <- sequence[!partition, pos]
# Computing p(x)
px_all <- base.freq(as.DNAbin(A), all = TRUE)
p_x <- px_all[c("a", "c", "g", "t", "-")]
# Computing p(y)
py_all <- base.freq(as.DNAbin(B), all = TRUE)
p_y <- py_all[c("a", "c", "g", "t", "-")]
# Computing weight
#w_x <- length(A)/length(sequence)
#w_y <- length(B)/length(sequence)
w_x <- length(A) / DIM(sequence)
w_y <- length(B) / DIM(sequence)
I <- 0
entr_xy <- 0
entr_x <- 0
entr_y <- 0
for (i in c(1:5)) {
if (p_xy[i] != 0) {
entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
}
if (p_x[i] != 0) {
entr_x <- entr_x - p_x[i] * log2(p_x[i])
}
if (p_y[i] != 0) {
entr_y <- entr_y - p_y[i] * log2(p_y[i])
}
}
I <- entr_xy - w_x * entr_x - w_y * entr_y
#print(paste("I =",I))
#   for(i in c(1:5)){
# if(p_x[i] !=0 ){
#   I <- I - w_y*p_y[i]*log2(p_x[i])
# }
# if(p_y[i] != 0){
#   I <- I - w_x*p_x[i]*log2(p_y[i])
# }
return(I)
}
DIM <- function(A) {
if (class(A)[1] == "matrix") {
size <- dim(A)[1]
} else {
size <- 1
}
return(size)
}
infotree <- function(sequence) {
#input:
# sequence -- matrix of characters
# output:
# Newick string representing minimum information gain tree
# if there are only two sequences return dichotomous tree
l = DIM(sequence)
names = row.names(sequence)
if (l == 1) {
tree_string <- names[1]
} else if (l == 2) {
tree_string <- paste("(", names[1], ", ", names[2], ")", sep = "")
} else{
# There are more than two sequences so we must find the optimal partition.
# Initialize the data
partition <- as.logical(splitset(l)[2, ])
I <- 0
for (j in 1:dim(sequence)[2]) {
#print(paste("I =",I))
I <- I + mutual_info(partition, sequence, j)
}
max_val <- I
max_part <- partition
for (i in 2:(2 ^ (l - 1))) {
# Run through all possible partitions
I <- 0
# Compute overall mutual information
#print(paste("computing the ",i,"th partition"))
partition <- as.logical(splitset(l)[i, ])
for (j in 1:dim(sequence)[2]) {
I <- I + mutual_info(partition, sequence, j)
}
print(paste("I =", I))
if (I > max_val) {
max_val <- I
max_part <- partition
}
}
print(paste("The partition is ", max_part))
left_sequence <- sequence[max_part, , drop = FALSE]
right_sequence <- sequence[!max_part, , drop = FALSE]
left_string <- infotree(left_sequence)
right_string <- infotree(right_sequence)
tree_string <-
paste("(", left_string, ", ", right_string, ")", sep = "")
}
return(tree_string)
}
infotree(trr_sequence2)
plot(trr)
plot(trr[[1]])
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("TreeTools")
library("phyclust")
sequence <- ReadCharacters("coiii.nex")
rownames(sequence) <- names(as.DNAbin(read.nexus.data("coiii.nex")))
plot(read.tree(text = paste(agg_clustering(sequence), ";", sep="")))
source("utilities.R")
plot(read.tree(text = paste(agg_clustering(sequence), ";", sep="")))
trr <- rtreeshape(1,9,model = "yule")
plot(as.phylo(trr[[1]]))
trr_sequence <- as.character(simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA"))
image(as.DNAbin.character(trr_sequence))
D <- dist.dna(as.DNAbin.character(trr_sequence), model = "TN93")
trr <- rtreeshape(1,9,model = "yule")
plot(as.phylo(trr[[1]]))
trr_sequence <- as.character(simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA"))
image(as.DNAbin.character(trr_sequence))
div_tree <- infotree(trr_sequence)
agg_tree <- agg_clustering(trr_sequence)
agg_tree <- agg_clustering(trr_sequence)
rownames(trr_sequence)
forests <- make_newick(rownames(sequence))
x_names <- read.tree(text = paste(forests[1], ";", sep = ""))$tip.label
y_names <- read.tree(text = paste(forests[2], ";", sep = ""))$tip.label
max_dist <-
alg_info(matrix(sequence[x_names, ], nrow = length(x_names)),
matrix(sequence[y_names, ], nrow = length(y_names)))
x_names <- read.tree(text = paste(forests[1], ";", sep = ""))$tip.label
y_names <- read.tree(text = paste(forests[2], ";", sep = ""))$tip.label
print(x_names)
print(y_names)
max_dist <-
alg_info(matrix(sequence[x_names, ], nrow = length(x_names)),
matrix(sequence[y_names, ], nrow = length(y_names)))
max_pair <- c(1, 2)
#Subroutine for computing the closest two clusters
for (k in 1:(length(forests) - 1)) {
for (j in (k + 1):length(forests)) {
x_names <- read.tree(text = paste(forests[k], ";", sep = ""))$tip.label
y_names <- read.tree(text = paste(forests[j], ";", sep = ""))$tip.label
dist <-
alg_info(matrix(sequence[x_names, ], nrow = length(x_names)),
matrix(sequence[y_names, ], nrow = length(y_names)))
cat("Current pair: ",
x_names,
"/",
y_names,
"; affinity =",
dist,
"\n")
if (dist < max_dist) {
max_dist <- dist
max_pair <- c(k, j)
}
}
}
#Just some diagnostics
#Subroutine for joining the two forests
new_branch <-
paste("(", forests[max_pair[1]], ",", forests[max_pair[2]], ")", sep =
"")
forests <- forests[-max_pair]
forests <- c(forests, new_branch)
forests
plot(read.tree(text = paste(agg_clustering(sequence), ";", sep="")))
agg_tree <- agg_clustering(trr_sequence)
sequence <- trr_sequence
x_names <- read.tree(text = paste(forests[1], ";", sep = ""))$tip.label
y_names <- read.tree(text = paste(forests[2], ";", sep = ""))$tip.label
print(x_names)
print(y_names)
max_dist <-
alg_info(matrix(sequence[x_names, ], nrow = length(x_names)),
matrix(sequence[y_names, ], nrow = length(y_names)))
max_pair <- c(1, 2)
#Subroutine for computing the closest two clusters
for (k in 1:(length(forests) - 1)) {
for (j in (k + 1):length(forests)) {
x_names <- read.tree(text = paste(forests[k], ";", sep = ""))$tip.label
y_names <- read.tree(text = paste(forests[j], ";", sep = ""))$tip.label
dist <-
alg_info(matrix(sequence[x_names, ], nrow = length(x_names)),
matrix(sequence[y_names, ], nrow = length(y_names)))
cat("Current pair: ",
x_names,
"/",
y_names,
"; affinity =",
dist,
"\n")
if (dist < max_dist) {
max_dist <- dist
max_pair <- c(k, j)
}
}
}
x_names <- read.tree(text = paste(forests[1], ";", sep = ""))$tip.label
y_names <- read.tree(text = paste(forests[2], ";", sep = ""))$tip.label
print(x_names)
print(y_names)
max_dist <-
alg_info(matrix(sequence[x_names, ], nrow = length(x_names)),
matrix(sequence[y_names, ], nrow = length(y_names)))
max_pair <- c(1, 2)
forests <- make_newick(rownames(sequence))
x_names <- read.tree(text = paste(forests[1], ";", sep = ""))$tip.label
y_names <- read.tree(text = paste(forests[2], ";", sep = ""))$tip.label
max_dist <-
alg_info(matrix(sequence[x_names, ], nrow = length(x_names)),
matrix(sequence[y_names, ], nrow = length(y_names)))
rownames(sequence)
read.tree(text = paste(forests[1], ";", sep = ""))
forests[1]
read.tree(text = "(tip 1);")
?read.tree
read.tree(text = "(tip 1);", comment.char = " ")
paste("tip", 1:9, sep = "")
?rtreeshape
trr[[1]]
names(trr)
trr$names
trr[[1]]$names
trr <- rtreeshape(1,9,model = "yule")
trr[[1]]$names <- paste("tip", 1:9, sep = "")
plot(as.phylo(trr[[1]]))
trr_sequence <- as.character(simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA"))
image(as.DNAbin.character(trr_sequence))
div_tree <- infotree(trr_sequence)
agg_tree <- agg_clustering(trr_sequence)
plot(trr[[1]])
title("Original")
trr <- rtreeshape(1,9,model = "yule")
trr[[1]]$names <- paste("tip", 1:9, sep = "")
plot(as.phylo(trr[[1]]))
trr_sequence <- as.character(simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA"))
image(as.DNAbin.character(trr_sequence))
div_tree <- infotree(trr_sequence)
agg_tree <- agg_clustering(trr_sequence)
plot(as.phylo(trr[[1]]))
title("Original")
plot(trr[[1]])
title("Original")
plot(trr[[1]])
title("Original")
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(div_tree, ";", sep = "")))
title("Divisive tree")
plot(read.tree(text = paste(agg_tree, ";", sep = "")))
title("Agglomerative tree")
plot(trr[[1]])
title("Original")
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(div_tree, ";", sep = "")))
title("Divisive tree")
plot(read.tree(text = paste(agg_tree, ";", sep = "")))
title("Agglomerative tree")
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(div_tree, ";", sep = "")))
title("Divisive tree")
plot(read.tree(text = paste(agg_tree, ";", sep = "")))
title("Agglomerative tree")
install.packages("phyclust")
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
setwd("/Users/shashanksule/Documents/info_theoretic_phylo/")
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("phyclust")
?read.paml
?paml.baseml
read.phylip("mc.paml")
