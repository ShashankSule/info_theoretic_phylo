---
title: "Information gain model for trees"
author: "Shashank Sule"
date: "14/06/2021"
output: html_document
---

```{r, echo=FALSE, eval = FALSE}
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
```

# The model

Let's write the simplest possible model. Let $\mathcal{S}$ be a set of OTU's and let $T(\mathcal{S})$ be a binary tree associated with $\mathcal{S}$. If $|\mathcal{S}| = n$ then the number of bifurcations in $T(\mathcal{S})$ is $n-1$ so the task is to figure out the bifurcations of $T(\mathcal{S})$ (or more directly, figure out a set of sensible bifurcations $B_i$ to make a tree with $\mathcal{S}$ as tips or leaves). In APE lingo, these bifurcations are called "splits". 

The information gain model of bifurcations/splits/partitions is as follows: Let $\mathcal{S}$ be a set of OTU's and $\mathcal{P} = A \sqcup B$ any partition. Supposing that $A$ are realizations of a random process $X$ and $B$ are realizations of a random process $Y$, then the information of $\mathcal{P}$ is $I(\mathcal{P}) := I(X,Y)$ where $I$ is some meaningful extension of mutual information to a random process. 

# Algorithm based on $I(\mathcal{P})$

In the case where $\mathcal{S}$ is aligned molecular sequence data, we assume that $X = X_n$ is a random process where $X_i$ takes values in a four-element set (i.e $\{A,C,G,T\}$) and $A_j$, the set of elements in the $j$th sites of $A$ is the set of realizations of $X_n$. We define the mutual information between $X$ and $Y$ to be $\frac{1}{n}\sum_{i=1}^{n}I(X_i, Y_i)$. Here 

$$
I(X_n, Y_n) = \sum_{(x,y) \in (X_n,Y_n)}p(x,y)\log_{2}(\frac{p(x,y)}{p(x)p(y)})
$$

The strategies for estimating these probabilities are: 

* 

$$
p(x,y) = \frac{\text{# Of pairs (x,y) seen in the data } A_n \times B_n}{|A_n \times B_n|}
$$

Note that $|A_n \times B_n| = (N - m)m$ where $A_n = m$, and each sequence has length $N$. 

* $p(x)$ is the frequency of $x$ in the given site in the data $A$ (similarly for $Y$). 

The optimal partition is a solution to 

$$
\mathcal{P}^* = \text{argmax}_{\mathcal{P}}\,I(\mathcal{P})
$$

The algorithm `infotree` for making a tree $T(\mathcal{S})$ with input $\mathcal{S}$ is as follows: 

a) Compute the optimal partition of $\mathcal{S}$ as $\mathcal{P}^* = A \sqcup B$. 
b) Run `infotree` on $A$ and $B$ as input.

# Implementation 

Let's try this out on a small example. First we make a tree with say 9 tips that evolves by the Yule model where the probability of a bifurcation is 1/2. 

```{r}
t <- rtreeshape(1,9,model = "yule")

plot(as.phylo(t[[1]]))
```

Using `simseq` we'll make sequences of say length 10 representing the tree

```{r}
seqs <- simSeq(as.phylo(t[[1]]),l=12)
```

Now let's set up the main body of the algorithm 

```{r}
mutual_info <- function(partition, sequence, pos){
# inputs:
# partition -- boolean denoting the partitions
# sequence -- dataframe of type DNAbin or phyDat with each row an aligned sequence
# pos -- integer denoting the position in the sequence

# output:
# I(partition)

A <- sequence[partition,pos]
B <- sequence[!partition,pos]

# Computing p(x)

p_x <- base.freq(as.DNAbin(A))

# Computing p(y)

p_y <- base.freq(as.DNAbin(B))

# Computing p(x,y)

p_xy <- matrix(nrow = 4, ncol = 4)

prod <- as.data.frame(expand.grid(A,B)) # Stores cartesian products of the A and B data


for(i in c(1:4)){
  for (j in c(1:4)) {
    counter <- 0  # Counter that stores how many times we hit a given pair (x,y)
    
    # Subroutine that does the counting: k runs through all the rows of prod 
    
    for (k in 1:nrow(prod)){
      if(all(prod[k,] == c(i,j))){
        counter <- counter + 1
      }
      
    }
    
    p_xy[i,j] <- counter/nrow(prod)
  }
}

I <- 0
for(i in c(1:4)){
  for(j in c(1:4)){
    
    if(p_x[i]*p_y[j] != 0){
      I <- I + p_xy[i,j]*log2(p_xy[i,j]/(p_x[i]*p_y[j]))
    }
    
  }
}

return(I)
}

```

```{r}
infopart <- function(sequence){
#input: 
# sequence -- aligned sequence in DNAbin or phyDat 
# output: 
# Newick string representing minimum information gain tree


# if there are only two sequences return dichotomous tree
if(length(sequence) == 2){
  tree_string <- paste("(", names(sequence)[1], ", ", names(sequence)[2], ")", sep = "")
}else{
  
  # There are more than two sequences so we must find the optimal partition
  max_val <- 0 
  max_part <- logical(length = length(sequence)) 
  
  for(i in 2:(2^length(sequence)-1)){ # Run through all possible partitions
    I <- 0 
    #if(i != 1 || i != 2^length(sequence)){ # Prevent getting the empty partitions
          # Compute overall mutual information 
          
          partition <- as.logical(splitset(length(sequence))[i,])
    
          for(j in 1:attr(sequence, "nr")){
            I <- I + mutual_info(partition, sequence, j)
          }
    #}
    
    
    if(I > max_val){
      max_val <- I 
      max_part <- partition
    }
  }
   left_sequence <- sequence[partition,]
   right_sequence <- sequence[!partition,]
   left_string <- infopart(left_sequence)
   right_string <- infopart(right_sequence)
   
   tree_string <- paste("(",left_string,", ",right_string,")", sep = "")

   
}

}
```

