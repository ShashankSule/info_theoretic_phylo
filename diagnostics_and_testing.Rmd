---
title: "Experiments with information theoretic tree generation"
output:
  github_document:
    pandoc_args: --webtex
---

```{r setup, include=FALSE}
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
library("readr")
source("utilities.R")
library("progress")
library("ggplot2")
library("phyclust")
library("TreeDist")
library("TreeTools")
library("dplyr")
```

This is the place where we'll be testing and exploring our divisive and agglomerative algorithms that make trees from aligned nucleotide sequences. Look for more extensive documentation on the computing process [here](https://github.com/ShashankSule/info_theoretic_phylo/blob/main/Computing_docs.md). 

We generate 100 blocks of sequence data for 10 species where each block corresponds to a tree randomly generated in the TN93 model. 

```{r echo=TRUE, results='hide', eval = FALSE}
#setwd("/Users/shashanksule/Documents/info_theoretic_phylo/")
n <- 1
trees <- list(n)
sequences <- list(n)
seeds <- list(n)
for(i in 1:n){
  
  #Initialize the .dat file and store the seed
  seeds[[i]] <- who_dat(seqs = 16,
                sites = 1000, 
                model = 6, 
                parameters = "5 5", 
                gamma = "0.5 4", 
                mutation = 3.5,
                equilibrium = "0.25 0.28 0.34 0.13",
                spit_seed = TRUE)
  
  #Simulate the trees and the sequences
  system("paml4.8/src/evolverRandomTree 5 paml4.8/MCbaseRTree.dat") 
  trees[[i]] <- write.tree(read.nexus("mctrees.nex"))
  sequences[[i]] <- ReadCharacters("mc.nex")
}
```

```{r echo=TRUE, results='hide', eval = FALSE}
num_sequence <- 100
trees <- list(num_sequence)
divisive <- list(num_sequence)
sequences <- list(num_sequence)
# agg_trees <- list(num_sequence)
# nj_trees <- list(num_sequence)

#read the original trees
for(i in c(1:num_sequence)){
  filename <- paste("TN93_Jul21/Trees/tree", i, ".txt", sep = "")
  trees[[i]] <- readChar(filename, file.info(filename)$size)
}

#read the divisive trees
for(i in c(1:num_sequence)){
  filename <- paste("TN93_Jul21/DivisiveTrees/tree", i, ".txt", sep = "")
  divisive[[i]] <- readChar(filename, file.info(filename)$size)
}
divisive <- lapply(divisive,  function(x) paste(x,";", sep = ""))

for(i in c(1:num_sequence)){
  filename <- paste("TN93_Jul21/Sequences/sequence", i, ".nex", sep = "")
  sequences[[i]] <- ReadCharacters(filename)
}
```


Let's compute some diagnostics! 

1. Robinson-Foulds distances: 

```{r, echo=TRUE,results='hide'}
#trials <- c(1:100)
start <- Sys.time()
divisive <- lapply(sequences, infotree)
finish <- Sys.time()
divisive <- lapply(divisive,  function(x) paste(x,";", sep = ""))
div_time <- finish - start()
```

```{r}
agglomerative <- list(100)

pb <- progress_bar$new(
      format = "  downloading [:bar] :percent eta: :eta",
      total = 100, clear = FALSE, width= 60)

for(i in 1:100){
  pb$tick()
  agglomerative[[i]] <- agg_clustering(sequences[[i]])
}


```


```{r, echo = TRUE}
# start <- Sys.time()
# agglomerative <- lapply(lapply(sequences, agg_clustering), function(x) paste(x,";", sep = ""))
# finish <- Sys.time()
```


```{r, echo = TRUE, results= 'hide'}
nj_trees <- sequences %>%
            lapply(as.DNAbin) %>%
            lapply(dist.dna) %>%
            lapply(nj) %>%
            lapply(write.tree)
```



1. Robinson-Foulds distances: 

```{r include=FALSE}
data <- data.frame(as.character(trees), as.character(divisive), as.character(nj_trees))
div_distance  <- mapply(RobinsonFoulds,
       lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
       lapply(data$as.character.divisive., function(x) read.tree(text = as.character(x))))
# agg_distance <- mapply(RobinsonFoulds,
#        lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
#        lapply(data$as.character.agglomerative., function(x) read.tree(text = as.character(x))))
nj_distance <- mapply(RobinsonFoulds,
       lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
       lapply(data$as.character.nj_trees., function(x) read.tree(text = as.character(x))))
# diagnostics <- data.frame(as.character(div_distance),
#                           as.character(agg_distance),
#                           as.character(nj_distance))
```

```{r, echo = FALSE}


# div_mean <- diagnostics$as.character.div_distance. %>%
#             as.character() %>%
#             as.numeric() %>%
#             mean()
# agg_mean <- diagnostics$as.character.agg_distance. %>% 
#             as.character() %>% 
#             as.numeric() %>% 
#             mean()
# nj_mean <-  diagnostics$as.character.nj_distance. %>% 
#             as.character() %>% 
#             as.numeric() %>% 
#             mean()

print(div_distance)
print(paste("Mean distance of divisive trees from original: ", mean(div_distance), sep = ""))
print(paste("The proportion of divisive trees has 0 RF distance from the original tree is: ", sum(div_distance == 0) / num_sequence, sep = ""))
hist(div_distance)

print(nj_distance)
print(paste("Mean distance of nj trees from original: ", mean(nj_distance), sep = ""))
print(paste("The proportion of nj trees has 0 RF distance from the original tree is: ", sum(nj_distance == 0) / num_sequence, sep = ""))
hist(nj_distance)
summary(nj_distance)
var(nj_distance)
# print(paste("Mean distance of divisive trees from original: ", div_mean, sep = ""))
# print(paste("Mean distance of agglomerative trees from original: ", agg_mean, sep = ""))
# print(paste("Mean distance of NJ trees from original: ", nj_mean, sep = ""))
```

2. Check the rootings using all.equals

```{r, echo = FALSE}
div_root  <- mapply(all.equal,
       lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
       lapply(data$as.character.divisive., function(x) read.tree(text = as.character(x))),
       use.edge.length = FALSE)
# agg_root <- mapply(all.equal,
#        lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
#        lapply(data$as.character.agglomerative., function(x) read.tree(text = as.character(x))),
#        use.edge.length = FALSE)
nj_root <- mapply(all.equal,
       lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
       lapply(data$as.character.nj_trees., function(x) read.tree(text = as.character(x))),
       use.edge.length = FALSE)
```

```{r, echo = FALSE}
print(div_root)
# print(agg_root)
print(nj_root)

summary(div_root)
# summary(agg_root)
summary(nj_root)
```


3. Low tolerance ultrametricity: 

```{r include=FALSE}
metricity <- data[,c(1,2,3)]
metricity[] <- metricity %>%
               lapply(function(x) is.ultrametric(read.tree(text = as.character(x))))

```

```{r}
summary(metricity)
```

4. High tolerance ultrametricity: 

```{r include=FALSE}
low_metricity <- data[,c(1,2,3)]
low_metricity[] <- low_metricity %>%
                   lapply(function(x) is.ultrametric(read.tree(text = as.character(x)), tol = 1e-2))
```

```{r}
summary(low_metricity)
print("Tolerance used: 1e-2")
```

5. 5. Check additivity: 

```{r include=FALSE}
# original_met <- logical(length = num_sequence)
original_add <- logical(length = num_sequence)
# div_met <- logical(length = num_sequence)
div_add <- logical(length = num_sequence)
# agg_met <- logical(length = num_sequence)
# agg_add <- logical(length = num_sequence)
# # nj_met <- logical(length = num_sequence)
nj_add <- logical(length = num_sequence)

for(i in c(1:num_sequence)){
  # original_met[i] <- is.ultrametric(read.tree(text = as.character(trees[i])))
  #original_add[i] <- is_additive(read.tree(text = as.character(trees[i])), 1e-15)
  original_add[i] <- is_additive(read.tree(text = as.character(trees[i])))
}

for(i in c(1:num_sequence)){
  # div_met[i] <- is.ultrametric(read.tree(text = as.character(divisive[i])))
  #div_add[i] <- is_additive(read.tree(text = as.character(divisive[i])), 1e-15)
  div_add[i] <- is_additive(read.tree(text = as.character(divisive[i])))
}

# for(i in c(1:num_sequence)){
#   # agg_met[i] <- is.ultrametric(read.tree(text = as.character(agglomerative[i])))
#   #agg_add[i] <- is_additive(read.tree(text = as.character(agglomerative[i])), 1e-15)
#   agg_add[i] <- is_additive(read.tree(text = as.character(agglomerative[i])))
# }
# 
for(i in c(1:num_sequence)){
  # nj_met[i] <- is.ultrametric(read.tree(text = as.character(nj_trees[i])))
  #nj_add[i] <- is_additive(read.tree(text = as.character(nj_trees[i])), 1e-15)
  nj_add[i] <- is_additive(read.tree(text = as.character(nj_trees[i])))
}
```

```{r}
# print(original_met)
# print(div_met)
# print(agg_met)
# print(nj_met)

# print(original_add)
# print(div_add)
# print(agg_add)
# print(nj_add)
summary(original_add)
summary(div_add)
summary(nj_add)
```


6. Relative distance between originals: 

```{r}
rel_distances <- matrix(rep(0,1e4), nrow = 100)
for(i in 1:99){
  for(j in (i+1):100)
 rel_distances[i,j] <- RobinsonFoulds(read.tree(text = trees[[i]]), read.tree(text = trees[[j]]))
}

```

```{r}
par(mar=c(5.1, 4.1, 4.1, 4.1))
plot(rel_distances[1:50,1:50])
```

# Reading files from disk without original trees 

```{r}

d_file_names <- paste("/TN93_Jul7/DivisiveTrees/100_16_",1:100,".txt", sep = "")
a_file_names <- paste("/TN93_Jul7/AgglomerativeTrees/100_16_",1:100,".txt", sep = "")
s_file_names <- paste("TN93_Jul7/SequenceData/100_16_",1:100,".nex", sep = "")
divisive <- mclapply(d_file_names, 
                     function(x) substr(read_file(paste(getwd(), x, sep = "")),
                                 1, 
                                 nchar(read_file(paste(getwd(), x, sep = "")))-2))
agglomerative <- mclapply(a_file_names, 
                     function(x) substr(read_file(paste(getwd(), x, sep = "")),
                                 1, 
                                 nchar(read_file(paste(getwd(), x, sep = "")))-1))
sequences <- mclapply(s_file_names, 
                      ReadCharacters)
nj_trees <- nj_trees <- sequences %>%
            mclapply(as.DNAbin) %>%
            mclapply(dist.dna) %>%
            mclapply(upgma) %>%
            mclapply(write.tree)

                     
```


Since we don't have the original trees, we'll compare them with neighbour-joining trees. 

```{r}
data <- data.frame(as.character(divisive), as.character(agglomerative), 
                   as.character(nj_trees))
div_distance  <- mapply(RobinsonFoulds,
       lapply(data$as.character.nj_trees., function(x) read.tree(text = as.character(x))),
       lapply(data$as.character.divisive., function(x) read.tree(text = as.character(x))))
agg_distance <- mapply(RobinsonFoulds,
       lapply(data$as.character.nj_trees., function(x) read.tree(text = as.character(x))),
       lapply(data$as.character.agglomerative., function(x) read.tree(text = as.character(x))))
# nj_distance <- mapply(RobinsonFoulds,
#        lapply(data$as.character.trees., function(x) read.tree(text = as.character(x))),
#        lapply(data$as.character.nj_trees., function(x) read.tree(text = as.character(x))))
diagnostics <- data.frame(as.numeric(div_distance), 
                          as.numeric(agg_distance))
```

Now we'll filter those that have zero robinson-foulds distances 

```{r}
index <- which(diagnostics$as.numeric.div_distance. + diagnostics$as.numeric.agg_distance. == 0)
```


Finally, we'll make a single plot with the branch lengths compared against the neighbour-joining ones: 

```{r}
# i <- index[1]
# nj_lengths <- read.tree(text = nj_trees[[i]])$edge.length
#     d_lengths <- read.tree(text = divisive[[i]])$edge.length
#     plot(nj_lengths, d_lengths)

cl <- rainbow(length(index))

for (i in index){
    nj_lengths <- read.tree(text = nj_trees[[i]])$edge.length
    d_lengths <- read.tree(text = divisive[[i]])$edge.length
    plot(nj_lengths[order(nj_lengths)], d_lengths[order(nj_lengths)])
}
```

```{r}
plot(read.tree(text = nj_trees[[7]]))
edgelabels(read.tree(text = nj_trees[[7]])$edge.length, font= 0.5)
```

```{r}
plot(read.tree(text = divisive[[7]]))
edgelabels(signif(read.tree(text = divisive[[7]])$edge.length, digits = 4), font= 0.5)
```

```{r}
read.tree(text = divisive[[7]])$edge.length
read.tree(text = nj_trees[[7]])$edge.length
```

