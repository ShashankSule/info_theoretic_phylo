---
title: "Information theoretic agglomerative clustering"
output:
  github_document:
    pandoc_args: --webtex
---

```{r setup, include=FALSE}
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("TreeTools")
library("phyclust")
```

# Agglomerative Clustering via Kraskov et al.

Let's write $D(X,Y) = 1 - I(X,Y)/\max{H(X), H(Y)}$ (for the 1 species case we assume the denominator is just 1). Kraskov et al approximate this mutual information through its algorithmic counterpart: $I(X,Y) \approx K(X) + K(Y) - H(XY) = H(x) + H(y) - H(xy)$ where $xy$ represents the concatenated data. Then the agglomerative algorithm based on Press et al. is as follows: 

1. Maintain an active `char` list `tree` denoting tips of the tree
2. Parse through `tree` and find the two closest clusters 
3. Update `tree` by merging the two clusters via tree joining `t1 + t2`. 

Q: How to make this work in a data structure? Hmmm. 

```{r}
sequence <- ReadCharacters("coiii.nex")
rownames(sequence) <- names(as.DNAbin(read.nexus.data("coiii.nex")))

```

```{r}
plot(read.tree(text = paste(agg_clustering(sequence), ";", sep="")))
```

# Other agglomerative methods 

We'll use the ones shown in APER

1. UPGMA

```{r}
trials <- as.DNAbin.character(sequence, all = TRUE)
M <- dist.dna(trials)

plot(upgma(M))
```

2. Neighbour joining 

```{r}
mod <- list("JC69")
```


# Testing trees 

Workflow: 

1. Make a random tree (and make sure that the tip labels don't have spaces in them! They cause issues with the `read.tree` )

```{r}
trr <- rtreeshape(1,9,model = "yule")
trr[[1]]$names <- paste("tip", 1:9, sep = "")
plot(as.phylo(trr[[1]]))
```

2. Generate sequence using `simSeq`. Make sure to store it as a character array!!

```{r}
trr_sequence <- as.character(simSeq(as.phylo(trr[[1]]),l=1000, type = "DNA"))
image(as.DNAbin.character(trr_sequence))
```

3. Make a divisive and agglomerative tree! 


```{r}
div_tree <- infotree(trr_sequence)
```

```{r}
agg_tree <- agg_clustering(trr_sequence)
```
3. Compare original, divisive and agglomerative trees! 

```{r}
plot(trr[[1]])
title("Original")
```

```{r}
layout(matrix(c(1,2), 1, 2))
plot(read.tree(text = paste(div_tree, ";", sep = "")))
title("Divisive tree")
plot(read.tree(text = paste(agg_tree, ";", sep = "")))
title("Agglomerative tree")
```


2. Compute both divisive and agglomerative trees 
3. Compare the original tree with the simulated trees via different tree distances 
4. Explore rooting


