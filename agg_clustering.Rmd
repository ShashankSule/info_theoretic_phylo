---
title: "Information theoretic agglomerative clustering"
output:
  github_document:
    pandoc_args: --webtex
---

```{r setup, include=FALSE}
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("TreeTools")
```

# Agglomerative Clustering via Kraskov et al.

Let's write $D(X,Y) = 1 - I(X,Y)/\max{H(X), H(Y)}$ (for the 1 species case we assume the denominator is just 1). Kraskov et al approximate this mutual information through its algorithmic counterpart: $I(X,Y) \approx K(X) + K(Y) - H(XY) = H(x) + H(y) - H(xy)$ where $xy$ represents the concatenated data. Then the algorithm based on Press et al. is as follows: 

1. Maintain an active `char` list `tree` denoting tips of the tree
2. Parse through `tree` and find the two closest clusters 
3. Update `tree` by merging the two clusters via tree joining `t1 + t2`. 

Q: How to make this work in a data structure? Hmmm. 

```{r}
sequence <- ReadCharacters("coiii.nex")
rownames(sequence) <- names(as.DNAbin(read.nexus.data("coiii.nex")))

```


```{r}
alg_info <- function(seqx, seqy){

n <- dim(seqx)[2] # stores number of sites 
I_alg <- 0

for(j in 1:n){
  
  
  # compute the algorithmic mutual information between two sequences at one site
  
  pxy_all <- base.freq(as.DNAbin(c(seqx[,j],seqy[,j])), all = TRUE)
  p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
  
  px_all <- base.freq(as.DNAbin(seqx[,j]), all = TRUE)
  p_x <- px_all[c("a", "c", "g", "t", "-")]
  
  # Computing p(y)
  py_all <- base.freq(as.DNAbin(seqy[,j]), all = TRUE)
  p_y <- py_all[c("a", "c", "g", "t", "-")]
  
  entr_xy <- 0
  
  entr_x <- 0
  
  entr_y <- 0 
  
  I_alg_site <- 0
  for(i in c(1:5)){
    
    if(p_xy[i] != 0){
      entr_xy <- entr_xy - p_xy[i]*log2(p_xy[i])
    }
    
    if(p_x[i] != 0){
      entr_x <- entr_x - p_x[i]*log2(p_x[i])
    }
    
    if(p_y[i] != 0){
      entr_y <- entr_y - p_y[i]*log2(p_y[i])
    }
    
    
  }
  
  I_alg_site <- entr_x + entr_y - entr_xy 
  I_alg <- I_alg + I_alg_site
}

  
   return(I_alg)
 }

```


```{r}
#agg_clustering <- function(sequence){
#inputs: 
# sequence -- aligned dna sequence in phyDat
#ouput:
# tree in newick format 
forests <- make_newick(rownames(sequence))

if(length(forests) == 1){
  
  # Just one species 
  tree_string <- forests[1]
} else if(length(forests) == 2){
  
  # Just two species 
  tree_string <- make_newick(paste(forests[1],",",forests[2],sep = ""))
} else{
  
  #More than two species 
  
  end <- length(forests) - 2 
  for(i in c(1:end)){ #Do this subroutine n-2 times! 
    
    x_names <- read.tree(text = paste(forests[1],";",sep=""))$tip.label
    y_names <- read.tree(text = paste(forests[2],";",sep=""))$tip.label
    
    max_dist <- alg_info(matrix(sequence[x_names,],nrow = length(x_names)), 
                         matrix(sequence[y_names,],nrow = length(y_names)))
    max_pair <- c(1,2)
    
    #Subroutine for computing the closest two clusters 
    
    for(k in 1:(length(forests)-1) ){
      for(j in (k+1):length(forests) ){
        
        x_names <- read.tree(text = paste(forests[k],";",sep=""))$tip.label
        y_names <- read.tree(text = paste(forests[j],";",sep=""))$tip.label
        dist <- alg_info(matrix(sequence[x_names,],nrow = length(x_names)), 
                         matrix(sequence[y_names,],nrow = length(y_names)))
        if(dist > max_dist){
          max_dist <- dist
          max_pair <- c(k,j)
        }
        
      }
    }
    
    #Subroutine for joining the two forests 
    new_branch <- make_newick(forests[max_pair])
    forests[- max_pair]
    forests <- c(forests,new_branch)
  }
  
  tree_string <- make_newick(paste(forests[1],",",forests[2],sep = ""))
}


#}
```

