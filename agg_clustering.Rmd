---
title: "Information theoretic agglomerative clustering"
output:
  github_document:
    pandoc_args: --webtex
---

```{r setup, include=FALSE}
library("adegenet")
library("ape")
library("apTreeshape")
library("BoSSA")
library("diversitree")
library("pegas")
library("phangorn")
library("phylobase")
#library("phyloch")
library("seqinr")
source("utilities.R")
library("ggplot2")
library("TreeDist")
library("TreeTools")
library("phyclust")
```

Let's write the variation of information as $VI(X,Y) = 2H(X,Y) - H(X) + H(Y)$. We then approximate it through its "algorithmic" counterpart: $VI(X,Y) \approx 2H(X \cup Y) - H(X) - H(Y)$ Then the agglomerative algorithm based on Press et al. is as follows: 

1. Maintain an active `char` list `forests` denoting tips of the tree
2. Parse through `forests` and find the two closest clusters 
3. Update `forest` by merging the two clusters via tree joining `t1 + t2`. 

Moreover, when two forests $X$ and $Y$ are joined into $(X,Y)$ the branch length from the node to each tip $X$ and $Y$ is taken to be $1/2 VI(X,Y)$. We write it up as follows: 

```{r,include = FALSE, eval = FALSE}
site_info <- function(seq, name1, name2) {
  #w_x <- length(seqx) / (length(seqx) + length(seqy))
  #w_y <- length(seqy) / (length(seqx) + length(seqy))
  seqx <- seq[name1]
  seqy <- seq[name2]

  pxy_all <- base.freq(as.DNAbin(c(seqx, seqy)), all = TRUE)
  p_xy <- pxy_all[c("a", "c", "g", "t", "-")]

  px_all <- base.freq(as.DNAbin(seqx), all = TRUE)
  p_x <- px_all[c("a", "c", "g", "t", "-")]

  # Computing p(y)
  py_all <- base.freq(as.DNAbin(seqy), all = TRUE)
  p_y <- py_all[c("a", "c", "g", "t", "-")]

  entr_xy <- 0
  entr_x <- 0
  entr_y <- 0
  
  for (i in c(1:5)) {
    if (p_xy[i] != 0) {
      entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
    }

    if (p_x[i] != 0) {
      entr_x <- entr_x - p_x[i] * log2(p_x[i])
    }

    if (p_y[i] != 0) {
      entr_y <- entr_y - p_y[i] * log2(p_y[i])
    }
  }
  I_alg_site <- 2 * entr_xy - entr_x - entr_y
  return(I_alg_site)
}

```

```{r,include=FALSE, eval = FALSE}
alg_info <- function(seq_matrix, x_names, y_names) {
  I_alg <- sum(apply(seq_matrix, 2, site_info, name1 = x_names, name2 = y_names))
  
  # n <- dim(seqx)[2] # stores number of sites
  # 
  # w_x <- nrow(seqx) / (nrow(seqx) + nrow(seqy))
  # w_y <- nrow(seqy) / (nrow(seqx) + nrow(seqy))
  # 
  # I_alg <- 0
  # 
  # for (j in 1:n) {
  #   # compute the algorithmic mutual information between two sequences at one site
  #   
  #   pxy_all <- base.freq(as.DNAbin(c(seqx[, j], seqy[, j])), all = TRUE)
  #   p_xy <- pxy_all[c("a", "c", "g", "t", "-")]
  #   
  #   px_all <- base.freq(as.DNAbin(seqx[, j]), all = TRUE)
  #   p_x <- px_all[c("a", "c", "g", "t", "-")]
  #   
  #   # Computing p(y)
  #   py_all <- base.freq(as.DNAbin(seqy[, j]), all = TRUE)
  #   p_y <- py_all[c("a", "c", "g", "t", "-")]
  #   
  #   entr_xy <- 0
  #   
  #   entr_x <- 0
  #   
  #   entr_y <- 0
  #   
  #   I_alg_site <- 0
  #   for (i in c(1:5)) {
  #     if (p_xy[i] != 0) {
  #       entr_xy <- entr_xy - p_xy[i] * log2(p_xy[i])
  #     }
  #     
  #     if (p_x[i] != 0) {
  #       entr_x <- entr_x - p_x[i] * log2(p_x[i])
  #     }
  #     
  #     if (p_y[i] != 0) {
  #       entr_y <- entr_y - p_y[i] * log2(p_y[i])
  #     }
  #     
  #     
  #   }
  #   
  #   I_alg_site <- 2 * entr_xy - entr_x - entr_y
  #   I_alg <- I_alg + I_alg_site
  # }
  # 
  # 
  return(I_alg)
}

```


```{r, echo = TRUE, eval=FALSE}
agg_clustering <- function(sequence) {
  #inputs:
  # sequence -- aligned dna sequence in phyDat
  #ouput:
  # tree in newick format
  tips <- rownames(sequence)
  forests <- make_newick(tips)
  num_sites = ncol(sequence)
  
  if (length(forests) == 1) {
    # Just one species
    tree_string <- forests[1]
  } else if (length(forests) == 2) {
    # Just two species
    # tree_string <-
    #   make_newick(paste(forests[1], ",", forests[2], sep = ""))
    branch <- alg_info(sequence, tips[1], tips[2])/num_sites
    tree_string <- paste("(", tips[1], ":", branch/2, ", ", tips[2], ":", branch/2, ")", sep = "")
  } else{
    #More than two species
    
    end <- length(forests) - 3
    dist_matrix <- matrix(0, end+3, end+3)

    x_names <- read.tree(text = paste(forests[1], ";", sep = ""))$tip.label
    y_names <- read.tree(text = paste(forests[2], ";", sep = ""))$tip.label
    #print(x_names)
    #print(y_names)

    max_dist <- alg_info(sequence, x_names, y_names)
    max_pair <- c(1, 2)

    #Subroutine for computing the closest two clusters

    for (k in 1:(length(forests) - 1)) {
      for (j in (k + 1):length(forests)) {
        x_names <- read.tree(text = paste(forests[k], ";", sep = ""))$tip.label
        y_names <- read.tree(text = paste(forests[j], ";", sep = ""))$tip.label
        # dist <-
        #   alg_info(matrix(sequence[x_names, ], nrow = length(y_names)))
        dist <- alg_info(sequence, x_names, y_names)
        cat("Current pair: ", x_names, "/", y_names, "; IG =", dist,"\n")
        dist_matrix[k,j] <- dist
        if (dist < max_dist) {
          max_dist <- dist
          max_pair <- c(k, j)
        }
      }
    }

    #Subroutine for joining the two forests
    new_branch <- paste("(", forests[max_pair[1]], ",", forests[max_pair[2]], ")", sep = "")
    forests <- forests[-max_pair]
    forests <- c(forests, new_branch)
    new_tip <- paste("(", tips[max_pair[1]], ":", max_dist/(num_sites*2), ",", tips[max_pair[2]], ":", max_dist/(num_sites*2), ")", sep = "")
    #print(new_tip)
    tips <- tips[-max_pair]
    tips <- c(tips, new_tip)
    dist_matrix <- dist_matrix[-max_pair, -max_pair]
    dist_matrix <- rbind(dist_matrix, integer(end+1))
    dist_matrix <- cbind(dist_matrix, integer(end+2))
    
    for(i in c(1:end)){
      l <- length(forests)
      #first calculate the new distances
      for(j in 1:(l-1)) {
        x_names <- read.tree(text = paste(forests[j], ";", sep = ""))$tip.label
        y_names <- read.tree(text = paste(forests[l], ";", sep = ""))$tip.label
        dist <- alg_info(sequence, x_names, y_names)
        cat("Current pair: ", x_names, "/", y_names, "; IG =", dist,"\n")
        dist_matrix[j,l] <- dist
      }
      
      #find the minimum distance
      dist_matrix[row(dist_matrix)>=col(dist_matrix)] <- NA
      max_pair <- arrayInd(which.min(dist_matrix), dim(dist_matrix))
      max_dist <- dist_matrix[max_pair]
      
      new_branch <- paste("(", forests[max_pair[1]], ",", forests[max_pair[2]], ")", sep = "")
      forests <- forests[-max_pair]
      forests <- c(forests, new_branch)
      new_tip <- paste("(", tips[max_pair[1]], ":", max_dist/(num_sites*2), ",", tips[max_pair[2]], ":", max_dist/(num_sites*2), ")", sep = "")
      #print(new_tip)
      tips <- tips[-max_pair]
      tips <- c(tips, new_tip)
      dist_matrix <- dist_matrix[-max_pair, -max_pair]
      dist_matrix <- rbind(dist_matrix, integer(l-2))
      dist_matrix <- cbind(dist_matrix, integer(l-1))
    }

    x_names <- read.tree(text = paste(forests[1], ";", sep = ""))$tip.label
    y_names <- read.tree(text = paste(forests[2], ";", sep = ""))$tip.label
    branch <- alg_info(sequence, x_names, y_names)/num_sites
    tree_string <- paste("(", tips[1], ":", branch/2, ",", tips[2], ":", branch/2, ")", sep = "")
  }
  #print(tree_string)
  return(tree_string)
}
```

Now let's see how it performs on the Co3 dataset from Cummings et al: 

```{r, echo=TRUE}
sequence <- ReadCharacters("coiii.nex")
rownames(sequence) <- names(as.DNAbin(read.nexus.data("coiii.nex")))

```

```{r}
plot(read.tree(text = paste(agg_clustering(press_data), ";", sep="")))
```

# Other agglomerative methods 

We'll use the ones shown in APER

1. UPGMA

```{r}
trials <- as.DNAbin.character(sequence, all = TRUE)
M <- dist.dna(trials)
```

```{r}
plot(upgma(M)); axisPhylo()
```

2. Neighbour joining 

```{r}
plot(nj(M)); axisPhylo()
```

